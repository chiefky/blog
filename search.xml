<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>article title</title>
      <link href="/blog/2021/08/27/article-title/"/>
      <url>/blog/2021/08/27/article-title/</url>
      
        <content type="html"><![CDATA[<p>hello 这是一个test！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/2021/08/27/hello-world/"/>
      <url>/blog/2021/08/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内存管理</title>
      <link href="/blog/2021/08/20/nei-cun-guan-li/"/>
      <url>/blog/2021/08/20/nei-cun-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="1-内存布局（内存分区）"><a href="#1-内存布局（内存分区）" class="headerlink" title="1. 内存布局（内存分区）"></a>1. 内存布局（内存分区）</h1><p>共享库（libobjc.A.dylib等）与内核空间的内存布局在栈区之上;如下图：</p><img src="/Users/tangh/yuki/iOS练习Demos/YLNote/YLNote/latest/个人笔记/文章/images/内存布局_0.jpg" alt="内存分布" style="zoom:100%;" /><ul><li><p><strong>内核区</strong>：用于加载内核代码，预留1GB</p></li><li><p><strong>共享区：用于加载系统库，例如:libobjc.a.dylib</strong></p></li><li><p><strong>栈区</strong>：创建临时变量时由编译器自动分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。栈区的内存地址一般是0x7开头,从高地址到底地址分配内存空间（**<font color=red>TaggedPointer</font>**）</p></li><li><p><strong>堆区</strong>：那些由 new alloc 创建的对象所分配的内存块，它们的释放系统不会主动去管，由我们的开发者去告诉系统什么时候释放这块内存(一个对象引用计数为0是系统就会回销毁该内存区域对象)。一般一个 new 就要对应一个release。在ARC下编译器会自动在合适位置为OC对象添加release操作。会在当前线程Runloop退出或休眠时销毁这些对象，MRC则需程序员手动释放。堆可以动态地扩展和收缩。堆区的内存地址一般是0x6开头,从底地址到高地址分配内存空间</p></li><li><p><strong>未初始化数据（静态区）</strong>：BSS段又称静态区，未初始化的全局变量，静态变量存放在这里。一旦初始化就会被回收，并且将数据转存到数据段中。</p></li><li><p><strong>已初始化数据（常量区）</strong>：数据段又称常量区，专门存放常量，直到程序结束的时候才会被回收</p></li><li><p><strong>代码段</strong>：用于存放程序运行时的代码，代码会被编译成二进制存进内存的程序代码区。程序结束时系统会自动回收存储在代码段中的数据。</p></li><li><p><strong>保留区</strong>：内存有4MB保留，地址从低到高递增</p><p>如何查看对象地址：</p><img src="../images/内存布局_1.jpg" alt="内存分布-1" style="zoom:80%;" /></li></ul><h1 id="2-内存管理方案"><a href="#2-内存管理方案" class="headerlink" title="2. 内存管理方案"></a>2. 内存管理方案</h1><ul><li><p>堆区：由开发者（借助<font color="red">引用计数</font>）管理的，需要告诉系统什么时候释放内存。</p><p>ARC下：编译器会自动在合适的时候插入引用计数管理代码（<code>retain</code>、<code>release</code>、<code>autorelease</code>）；</p><p>MRC下：需要开发者手动释放。</p></li><li><p>栈区、其他区：编译器自动分配，由系统管理，在不需要的时候自动清除；</p></li></ul><h1 id="3-引用计数原理"><a href="#3-引用计数原理" class="headerlink" title="3. 引用计数原理"></a>3. 引用计数原理</h1><p>引用计数是一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的<strong>被引用次数</strong>保存起来，当被引用次数<strong>变为零</strong>时就将其<strong>释放</strong>的过程。使用引用计数技术可以实现自动资源管理的目的。同时引用计数还可以指使用引用计数技术回收未使用资源的垃圾回收算法。</p><h2 id="3-1-引用计数规则"><a href="#3-1-引用计数规则" class="headerlink" title="3.1 引用计数规则"></a>3.1 引用计数规则</h2><ol><li>自己生成的对象，自己持有。（alloc,new,copy,mutableCopy等）</li><li>非自己生成的对象，自己也能持有。（retain 等）</li><li>不再需要自己持有的对象时释放。（release，dealloc 等）</li><li>非自己持有的对象无法释放。</li></ol><h2 id="3-2-alloc引起引用计数-1-的原因"><a href="#3-2-alloc引起引用计数-1-的原因" class="headerlink" title="3.2 alloc引起引用计数+1 的原因"></a>3.2 alloc引起引用计数+1 的原因</h2><p>答案看源码：</p><img src="../images/内存管理_retaincount_alloc2.png" alt="retaincount" style="zoom:80%;" /><img src="../images/内存管理_retaincount_alloc1.png" alt="retaincount" style="zoom:80%;" /><h1 id="4-Autoreleasepool"><a href="#4-Autoreleasepool" class="headerlink" title="4. Autoreleasepool"></a>4. Autoreleasepool</h1><h2 id="4-1-什么是Autoreleasepool"><a href="#4-1-什么是Autoreleasepool" class="headerlink" title="4.1 什么是Autoreleasepool?"></a>4.1 什么是Autoreleasepool?</h2><p>自动释放池是 <code>Objective-C</code> 开发中的一种自动内存回收管理的机制，为了替代开发人员手动管理内存，实质上是使用编译器在适当的位置插入<code>release</code>、<code>autorelease</code>等内存释放操作。当对象调用 <code>autorelease </code>方法后会被放到自动释放池中延迟释放时机，当缓存池需要清除<code>dealloc</code>时，会向这些 <code>Autoreleased </code>对象做 <code>release</code> 释放操作。</p><h2 id="4-2-对象什么时候释放"><a href="#4-2-对象什么时候释放" class="headerlink" title="4.2 对象什么时候释放"></a>4.2 对象什么时候释放</h2><p>以下A、B两种情况person分别什么时候释放(dealloc触发时机)？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// A:</span><br><span class="line">__weak id temp = nil;</span><br><span class="line">&#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    temp = person;</span><br><span class="line">&#125;</span><br><span class="line">// 插入的release操作</span><br><span class="line"> // call void @llvm.objc.storeStrong(i8** %19, i8* null) #3  ----retainCount == 0，dealloc</span><br><span class="line">// 插入NSLog 传入weak变量操作</span><br><span class="line"> // %20 = call i8* @llvm.objc.loadWeakRetained(i8** %6) #3</span><br><span class="line">NSLog(@&quot;temp = %@&quot;,temp);</span><br><span class="line">// 插入 weak release和destory</span><br><span class="line"> // call void @llvm.objc.release(i8* %20) #3, !clang.imprecise_release !10</span><br><span class="line"> // call void @llvm.objc.destroyWeak(i8** %6) #3</span><br><span class="line"> // call void @llvm.objc.autoreleasePoolPop(i8* %10)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>答案：</p><blockquote><p>先打印： [person dealloc]</p><p>后打印： temp = （null）</p><p>retainCount 减到0，立即释放，触发dealloc</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// B:</span><br><span class="line"></span><br><span class="line">+(instancetype)defaultPerson</span><br><span class="line">&#123;</span><br><span class="line">    return [[Person alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__weak id temp = nil;</span><br><span class="line">&#123;</span><br><span class="line">    Person *person = [Person defaultPerson]; </span><br><span class="line">   // %16 = notail call i8* @llvm.objc.retainAutoreleasedReturnValue(i8* %14) #3 ----retainCount == 2，retainAutoreleasedReturnValue中调了objc_retain(obj);</span><br><span class="line"></span><br><span class="line">    temp = person;</span><br><span class="line">&#125;</span><br><span class="line"> // call void @llvm.objc.storeStrong(i8** %21, i8* null) #3 ----retainCount == 1，延迟释放</span><br><span class="line"> // %22 = call i8* @llvm.objc.loadWeakRetained(i8** %6) #3</span><br><span class="line">//  invoke void (i8*, ...) @NSLog(i8* bitcast (%struct.__NSConstantString_tag* @_unnamed_cfstring_.35 to i8*), i8* %22) to label %23 unwind label %24</span><br><span class="line">NSLog(@&quot;temp = %@&quot;,temp);</span><br><span class="line">//   call void @llvm.objc.release(i8* %22) #3, !clang.imprecise_release !10</span><br><span class="line">//  call void @llvm.objc.destroyWeak(i8** %6) #3</span><br><span class="line">//  call void @llvm.objc.autoreleasePoolPop(i8* %10)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>答案：</p><blockquote><p>先打印： temp = <strong>&lt;Person: 0x10133d460&gt;</strong></p><p>后打印： [person dealloc]</p><p>retainCount减到1，对象延迟释放，等到autoreleasepool pop时，向pool内的对象发realse消息减到0才释放；</p></blockquote><h2 id="4-3-AutoreleasePool的使用"><a href="#4-3-AutoreleasePool的使用" class="headerlink" title="4.3 AutoreleasePool的使用"></a>4.3 AutoreleasePool的使用</h2><p><strong>初始化or创建</strong></p><p>MRC下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//1.生成一个NSAutoreleasePool对象</span><br><span class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">//2.创建对象</span><br><span class="line">id object = [[NSObject alloc] init];</span><br><span class="line">//3.对象调用autorelease方法</span><br><span class="line">[object autorelease];</span><br><span class="line">//4.废弃NSAutoreleasePool对象，会对释放池中的object发送release消息</span><br><span class="line">[pool drain];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ARC:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    //LLVM会在内部插入autorelease方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="TODO-面试题："><a href="#TODO-面试题：" class="headerlink" title="TODO: 面试题："></a>TODO: 面试题：</h3><p>以下代码有什么区别吗？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YLAnimal</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)animal &#123;</span><br><span class="line">  YLAnimal *ani = [YLAnimal alloc];</span><br><span class="line">  <span class="keyword">return</span> ani;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">  __<span class="keyword">weak</span> <span class="keyword">id</span> temp = <span class="literal">nil</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    YLAnimal *animal = [[YLAnimal alloc] init];</span><br><span class="line">    temp = animal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;temp = %@&quot;</span>,temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">  __<span class="keyword">weak</span> <span class="keyword">id</span> temp = <span class="literal">nil</span>;</span><br><span class="line">  &#123;</span><br><span class="line">      YLAnimal *animal = [YLAnimal animal];</span><br><span class="line">      temp = animal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;temp = %@&quot;</span>,temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>答：<code>alloc</code>方法初始化 的animal不会加入到autoreleasepool中，超出作用域后，retaincount减为0，立即释放；</p><p><code>anima</code>方法初始化的animal会加入到autoreleasepool中，超出作用域后，延迟到autoreleasepool pop，才会释放;</p><blockquote><p>引申：</p><p>加入到autoreleasepool的对象一定会释放吗？</p><p>答：不一定，autoreleasepool销毁时只是对其内部对象发送release消息，引用计数减1，此时若对象的引用计数减完后不为0，就不会被释放，也就是所谓的内存泄漏。</p><p>引发内存泄漏的情况有哪些？</p><ul><li>循环引用：<ul><li>block</li><li>A –&gt; B –&gt; A</li><li>A –&gt; B –&gt; C –&gt; A</li><li>NSObserver center (<font color="red">待补充</font>) </li></ul></li><li>NSObserver center (<font color="red">待补充</font>) </li><li></li></ul></blockquote><h2 id="4-4-ARC下-autoreleasepool-被编译成了什么"><a href="#4-4-ARC下-autoreleasepool-被编译成了什么" class="headerlink" title="4.4  ARC下@autoreleasepool {} 被编译成了什么"></a>4.4  ARC下<code>@autoreleasepool &#123;&#125; </code>被编译成了什么</h2><p>使用clang命令将main.m编译成main.cpp，查看相关代码，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译前：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，编译后把<code>@autoreleasePool</code>转换成一个<code>__AtAutoreleasePool </code>类型的局部私有变量<code>__AtAutoreleasePool __autoreleasepool</code>;然后查看一下<code>__AtAutoreleasePool</code>是什么？</p><p>对应main.cpp文件，main函数前面有<code>__AtAutoreleasePool</code>源码结构，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = <span class="built_in">objc_autoreleasePoolPush</span>();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;<span class="built_in">objc_autoreleasePoolPop</span>(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__AtAutoreleasePool</code>是结构体类型，其内包含：</p><ul><li>构造函数<code>__AtAutoreleasePool()</code></li><li>析构函数<code>~__AtAutoreleasePool(atautoreleasepoolobj)</code>。</li><li>atautoreleasepoolobj (就是我们常说的<code>POOL_BOUNDARY</code>桩对象，析构时，以此对象为参照物向此对象之后插入的对象全部发送release消息)</li></ul><p>关于<code>@autoreleasepool</code>就这些，接下来是<code>objc_autoreleasePoolPush()</code> 、<code>objc_autoreleasePoolPop(obj)</code>的实现，即关于<code>AutoreleasepoolPage</code>的探索；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::<span class="built_in">push</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NEVER_INLINE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage::<span class="built_in">pop</span>(ctxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5-AutoreleasepoolPage"><a href="#5-AutoreleasepoolPage" class="headerlink" title="5. AutoreleasepoolPage"></a>5. AutoreleasepoolPage</h1><h2 id="5-1-内存结构"><a href="#5-1-内存结构" class="headerlink" title="5.1 内存结构"></a>5.1 内存结构</h2><h3 id="AutoreleasepoolPage在内存中以双向链表形式存在，如图："><a href="#AutoreleasepoolPage在内存中以双向链表形式存在，如图：" class="headerlink" title="AutoreleasepoolPage在内存中以双向链表形式存在，如图："></a>AutoreleasepoolPage在内存中以双向链表形式存在，如图：</h3><p><img src="../images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-AutoreleasePoolPage_0.png" alt="双向链表"></p><h3 id="单个page的内存形态"><a href="#单个page的内存形态" class="headerlink" title="单个page的内存形态"></a>单个page的内存形态</h3><img src="../images/内存管理-autoreleasepage_1.png" alt="AutoreleasepoolPage" style="zoom:80%;" /><p><code>next</code> 指向了下一个为空的内存地址，如果 <code>next</code> 指向的地址加入一个 <code>object</code>，它就会如下图所示<strong>移动到下一个为空的内存地址中</strong>：</p><blockquote><p>注意：各变量在内存中的位置；</p></blockquote><h2 id="5-2-AutoreleasePoolPage部分关键源码"><a href="#5-2-AutoreleasePoolPage部分关键源码" class="headerlink" title="5.2  AutoreleasePoolPage部分关键源码"></a>5.2  AutoreleasePoolPage部分关键源码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> :</span> <span class="keyword">private</span> AutoreleasePoolPageData</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">thread_data_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE =</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">PAGE_MIN_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> COUNT = SIZE / <span class="built_in"><span class="keyword">sizeof</span></span>(id);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> MAX_FAULTS = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is </span></span><br><span class="line">    <span class="comment">// pushed and it has never contained any objects. This saves memory </span></span><br><span class="line">    <span class="comment">// when the top level (i.e. libdispatch) pushes and pops pools but </span></span><br><span class="line">    <span class="comment">// never uses them.</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> POOL_BOUNDARY nil</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AutoreleasePoolPage</span>(AutoreleasePoolPage *newParent) :</span><br><span class="line"><span class="built_in">AutoreleasePoolPageData</span>(<span class="built_in">begin</span>(),</span><br><span class="line"><span class="built_in">objc_thread_self</span>(),</span><br><span class="line">newParent,</span><br><span class="line">newParent ? <span class="number">1</span>+newParent-&gt;depth : <span class="number">0</span>,</span><br><span class="line">newParent ? newParent-&gt;hiwat : <span class="number">0</span>)&#123; &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">AutoreleasePoolPage</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function">id *<span class="title">add</span><span class="params">(id obj)</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> AutoreleasePoolPage *<span class="title">hotPage</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setHotPage</span><span class="params">(AutoreleasePoolPage *page)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">static</span> <span class="keyword">inline</span> AutoreleasePoolPage *<span class="title">coldPage</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    .</span></span><br><span class="line"><span class="function">    .</span></span><br><span class="line"><span class="function">    .</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AutoreleasePoolPageData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_AUTORELEASEPOOL_DEDUP_PTRS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AutoreleasePoolEntry</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> ptr: <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> count: <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uintptr_t</span> maxCount = <span class="number">65535</span>; <span class="comment">// 2^16 - 1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>((AutoreleasePoolEntry)&#123; .ptr = MACH_VM_MAX_ADDRESS &#125;.ptr == MACH_VM_MAX_ADDRESS, <span class="string">&quot;MACH_VM_MAX_ADDRESS doesn&#x27;t fit into AutoreleasePoolEntry::ptr!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">magic_t</span> <span class="keyword">const</span> magic; <span class="comment">//用来校验 `AutoreleasePoolPage`的结构是否完整；16</span></span><br><span class="line">__unsafe_unretained id *next; <span class="comment">//指向最新添加的 `autoreleased` 对象的下一个位置，初始化时指向  `begin()` ；8</span></span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;  <span class="comment">//指向当前线程；8</span></span><br><span class="line">AutoreleasePoolPage * <span class="keyword">const</span> parent;    <span class="comment">//指向父结点，第一个结点的 `parent` 值为 `nil` ；8</span></span><br><span class="line">AutoreleasePoolPage *child;     <span class="comment">//指向子结点，最后一个结点的 `child` 值为 `nil` ；8</span></span><br><span class="line"><span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;  <span class="comment">//代表深度，从 `0` 开始，往后递增 `1`；4</span></span><br><span class="line"><span class="keyword">uint32_t</span> hiwat; <span class="comment">//代表 `high water mark` ; 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AutoreleasePoolPageData</span>(__unsafe_unretained id* _next, <span class="keyword">pthread_t</span> _thread, AutoreleasePoolPage* _parent, <span class="keyword">uint32_t</span> _depth, <span class="keyword">uint32_t</span> _hiwat)</span><br><span class="line">: <span class="built_in">magic</span>(), <span class="built_in">next</span>(_next), <span class="built_in">thread</span>(_thread),</span><br><span class="line">  <span class="built_in">parent</span>(_parent), <span class="built_in">child</span>(nil),</span><br><span class="line">  <span class="built_in">depth</span>(_depth), <span class="built_in">hiwat</span>(_hiwat)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>通过源码直观可见：</strong></p><ol><li><code>AutoreleasePoolPage</code>是继承自<code>AutoreleasePoolPageData</code>。</li><li><code>AutoreleasePoolPageData</code>有一个parent、一个child变量，分别是一个<code>AutoreleasePoolPage</code>指针。</li><li>每一个<code>AutoreleasePoolPageData</code>都对应一个pthread_t线程</li><li><code>AutoreleasePoolPageData</code>结构体的大小为56字节</li></ol><h3 id="5-2-1-AutoreleasePoolPage-push"><a href="#5-2-1-AutoreleasePoolPage-push" class="headerlink" title="5.2.1 AutoreleasePoolPage::push()"></a>5.2.1 AutoreleasePoolPage::push()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        id *dest;</span><br><span class="line">          <span class="comment">//判断是否已经初始化AutoreleasePoolPage，slowpath()为小概率发生事件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">slowpath</span>(DebugPoolAllocation)) &#123;</span><br><span class="line">            <span class="comment">// Each autorelease pool starts on a new pool page.</span></span><br><span class="line">            dest = <span class="built_in">autoreleaseNewPage</span>(POOL_BOUNDARY); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dest = <span class="built_in">autoreleaseFast</span>(POOL_BOUNDARY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ⬆️ 这里的POOL_BOUNDARY就是我们常说的哨兵对象</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="关于”autoreleaseFast”核心方法的概括："><a href="#关于”autoreleaseFast”核心方法的概括：" class="headerlink" title="关于”autoreleaseFast”核心方法的概括："></a>关于”autoreleaseFast”核心方法的概括：</h5><ul><li><p>autoreleaseFullPage() ; // hotpage已满: 如果子页面存在，则将页面替换为子页面;不存在，则创建新页面</p></li><li><p>autoreleaseNoPage()；// hotpage不存在;</p><blockquote><p>第一步：先判断“是否有空占位符”，然后该标记标记，该报错报错，该返回empty pool placeholder返回empty pool placeholder；</p><p>第二步：确保占位符状态ok，且已经有了boundary，然后初始化一个page，并设置为hotPage；</p><p>第三步：page和占位符都就绪，先插入boundry对象，再add(obj)</p></blockquote></li><li><p>add(obj）；// hotpage存在，且未满：将当前对象加入pool中；(疑问❓ 这里返回的是谁的指针)</p></li></ul><h4 id="autoreleaseNewPage-方法–小概率发生事件"><a href="#autoreleaseNewPage-方法–小概率发生事件" class="headerlink" title="autoreleaseNewPage()方法–小概率发生事件"></a>autoreleaseNewPage()方法–小概率发生事件</h4><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __attribute__((noinline))</span><br><span class="line"><span class="function">id *<span class="title">autoreleaseNewPage</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前hotpage</span></span><br><span class="line">    AutoreleasePoolPage *page = <span class="built_in">hotPage</span>();</span><br><span class="line">    <span class="comment">//判断当前页是否存在，如果存在，则压栈对象</span></span><br><span class="line">    <span class="keyword">if</span> (page) <span class="keyword">return</span> <span class="built_in">autoreleaseFullPage</span>(obj, page);</span><br><span class="line">    <span class="comment">//如果不存在，则创建page</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">autoreleaseNoPage</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h4 id="autoreleaseFast-方法–大概率发生事件"><a href="#autoreleaseFast-方法–大概率发生事件" class="headerlink" title="autoreleaseFast()方法–大概率发生事件"></a>autoreleaseFast()方法–大概率发生事件</h4><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page = <span class="built_in">hotPage</span>();</span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;<span class="built_in">full</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">autoreleaseFullPage</span>(obj, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">autoreleaseNoPage</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h6 id="autoreleaseFullPage-方法"><a href="#autoreleaseFullPage-方法" class="headerlink" title="autoreleaseFullPage() 方法"></a>autoreleaseFullPage() 方法</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> __attribute__((noinline))</span><br><span class="line"><span class="function">id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The hot page is full. </span></span><br><span class="line">    <span class="comment">// Step to the next non-full page, adding a new page if necessary.</span></span><br><span class="line">    <span class="comment">// Then add the object to that page.</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(page == <span class="built_in">hotPage</span>());</span><br><span class="line">    <span class="built_in">ASSERT</span>(page-&gt;<span class="built_in">full</span>()  ||  DebugPoolAllocation);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历循环查找page是否已满</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//如果子页面存在，则将页面替换为子页面</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="comment">//如果子页面不存在，则创建新页面</span></span><br><span class="line">        <span class="keyword">else</span> page = <span class="keyword">new</span> <span class="built_in">AutoreleasePoolPage</span>(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;<span class="built_in">full</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置为当前hotPage</span></span><br><span class="line">    <span class="built_in">setHotPage</span>(page);</span><br><span class="line">    <span class="comment">//对象压栈</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="autoreleaseNoPage-方法"><a href="#autoreleaseNoPage-方法" class="headerlink" title="autoreleaseNoPage()方法"></a>autoreleaseNoPage()方法</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __attribute__((noinline))</span><br><span class="line"><span class="function">id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// &quot;No page&quot; could mean no pool has been pushed</span></span><br><span class="line">    <span class="comment">// or an empty placeholder pool has been pushed and has no contents yet</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(!<span class="built_in">hotPage</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> pushExtraBoundary = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//判断是否是空占位符，如果是，则压栈哨兵标识符置为YES</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">haveEmptyPoolPlaceholder</span>()) &#123;</span><br><span class="line">        pushExtraBoundary = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果对象不是哨兵对象，且没有Pool，则报错</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span></span><br><span class="line">                     <span class="string">&quot;autoreleased with no pool in place - &quot;</span></span><br><span class="line">                     <span class="string">&quot;just leaking - break on &quot;</span></span><br><span class="line">                     <span class="string">&quot;objc_autoreleaseNoPool() to debug&quot;</span>, </span><br><span class="line">                     <span class="built_in">objc_thread_self</span>(), (<span class="keyword">void</span>*)obj, <span class="built_in">object_getClassName</span>(obj));</span><br><span class="line">        <span class="built_in">objc_autoreleaseNoPool</span>(obj);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果对象是哨兵对象，且没有申请自动释放池内存，则设置一个空占位符存储在tls中，其目的是为了节省内存</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;</span><br><span class="line">        <span class="comment">// We are pushing a pool with no pool in place,</span></span><br><span class="line">        <span class="comment">// and alloc-per-pool debugging was not requested.</span></span><br><span class="line">        <span class="comment">// Install and return the empty pool placeholder.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setEmptyPoolPlaceholder</span>();<span class="comment">//设置空的占位符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are pushing an object or a non-placeholder&#x27;d pool.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install the first page.</span></span><br><span class="line">    <span class="comment">//初始化第一页</span></span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">new</span> <span class="built_in">AutoreleasePoolPage</span>(nil);</span><br><span class="line">    <span class="comment">//设置page为当前hotpage</span></span><br><span class="line">    <span class="built_in">setHotPage</span>(page);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Push a boundary on behalf of the previously-placeholder&#x27;d pool.</span></span><br><span class="line">    <span class="comment">//压栈哨兵的标识符为YES，则压栈哨兵对象</span></span><br><span class="line">    <span class="keyword">if</span> (pushExtraBoundary) &#123;</span><br><span class="line">        <span class="comment">//压栈哨兵</span></span><br><span class="line">        page-&gt;<span class="built_in">add</span>(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Push the requested object or pool.</span></span><br><span class="line">    <span class="comment">//压栈对象</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="add-obj-方法"><a href="#add-obj-方法" class="headerlink" title="add(obj)方法"></a>add(obj)方法</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id *<span class="title">add</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">full</span>());</span><br><span class="line">    <span class="built_in">unprotect</span>();</span><br><span class="line">    id *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></span><br><span class="line">    *next++ = obj;</span><br><span class="line">    <span class="built_in">protect</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-2-AutoreleasePoolPage-pop"><a href="#5-2-2-AutoreleasePoolPage-pop" class="headerlink" title="5.2.2 AutoreleasePoolPage::pop()"></a>5.2.2 AutoreleasePoolPage::pop()</h3><img src="../images/内存管理-autoreleasepage_pop_0.png" alt="pop-0" style="zoom:80%;" /><img src="../images/内存管理-autoreleasepage_pop_1.png" alt="pop-1" style="zoom:80%;" /><img src="../images/内存管理-autoreleasepage_pop_2.png" alt="pop-2" style="zoom:80%;" /><h5 id="其中核心三步："><a href="#其中核心三步：" class="headerlink" title="其中核心三步："></a>其中核心三步：</h5><ul><li>pageForPointer(token); 根据传入的哨兵对象的地址，取得哨兵对象所在的page地址；</li><li>releaseUntil(stop); 拿hotPage逐一减1，直到page的next指向boundary；</li><li>page-&gt;kill(); 方法删除双向链表中的每一个page</li></ul><h4 id="pageForPointer-方法-—-根据哨兵对象找到page"><a href="#pageForPointer-方法-—-根据哨兵对象找到page" class="headerlink" title="pageForPointer( ) 方法 —- 根据哨兵对象找到page"></a>pageForPointer( ) 方法 —- 根据哨兵对象找到page</h4><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> AutoreleasePoolPage *<span class="title">pageForPointer</span><span class="params">(<span class="keyword">uintptr_t</span> p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *result;</span><br><span class="line">    <span class="keyword">uintptr_t</span> offset = p % SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT</span>(offset &gt;= <span class="built_in"><span class="keyword">sizeof</span></span>(AutoreleasePoolPage));</span><br><span class="line"></span><br><span class="line">    result = (AutoreleasePoolPage *)(p - offset);</span><br><span class="line">    result-&gt;<span class="built_in">fastcheck</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读：</p><ol><li>哨兵对象地址与页面size(4096)取模—&gt;哨兵对象的偏移量</li><li>根据哨兵对象的地址减偏移量便可以得到根page的首地址—&gt;哨兵对象所在page页</li></ol></blockquote><h4 id="releaseUntil-stop-方法-—-释放对象"><a href="#releaseUntil-stop-方法-—-释放对象" class="headerlink" title="releaseUntil(stop)方法 —- 释放对象"></a>releaseUntil(stop)方法 —- 释放对象</h4><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseUntil</span><span class="params">(id *stop)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Not recursive: we don&#x27;t want to blow out the stack </span></span><br><span class="line">    <span class="comment">// if a thread accumulates a stupendous amount of garbage</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放AutoreleasePoolPage中的对象，直到next指向stop</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;</span><br><span class="line">        <span class="comment">// Restart from hotPage() every time, in case -release </span></span><br><span class="line">        <span class="comment">// autoreleased more objects</span></span><br><span class="line">        <span class="comment">// hotPage可以理解为当前正在使用的page</span></span><br><span class="line">        AutoreleasePoolPage *page = <span class="built_in">hotPage</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fixme I think this `while` can be `if`, but I can&#x27;t prove it</span></span><br><span class="line">        <span class="keyword">while</span> (page-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            <span class="built_in">setHotPage</span>(page);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        page-&gt;<span class="built_in">unprotect</span>();</span><br><span class="line">        <span class="comment">// obj = page-&gt;next; page-&gt;next--;</span></span><br><span class="line">     id obj = *--page-&gt;next;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span>*)page-&gt;next, SCRIBBLE, <span class="built_in"><span class="keyword">sizeof</span></span>(*page-&gt;next));</span><br><span class="line">        page-&gt;<span class="built_in">protect</span>();</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// POOL_BOUNDARY为nil，是哨兵对象</span></span><br><span class="line">        <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">         <span class="comment">// 释放obj对象</span></span><br><span class="line">            <span class="built_in">objc_release</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 重新设置hotPage</span></span><br><span class="line">    <span class="built_in">setHotPage</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">// we expect any children to be completely empty</span></span><br><span class="line"> <span class="keyword">for</span> (AutoreleasePoolPage *page = child; page; page = page-&gt;child) &#123;</span><br><span class="line">     <span class="built_in">assert</span>(page-&gt;<span class="built_in">empty</span>());</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="kill-方法-—-删除双向链表中的每一个page"><a href="#kill-方法-—-删除双向链表中的每一个page" class="headerlink" title="kill()方法 —- 删除双向链表中的每一个page"></a>kill()方法 —- 删除双向链表中的每一个page</h4><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Not recursive: we don&#x27;t want to blow out the stack </span></span><br><span class="line">    <span class="comment">// if a thread accumulates a stupendous amount of garbage</span></span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 找到链表最末尾的page</span></span><br><span class="line">    <span class="keyword">while</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage *deathptr;</span><br><span class="line">    <span class="comment">// 循环删除每一个page</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        deathptr = page;</span><br><span class="line">        page = page-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (page) &#123;</span><br><span class="line">            page-&gt;<span class="built_in">unprotect</span>();</span><br><span class="line">            page-&gt;child = nil;</span><br><span class="line">            page-&gt;<span class="built_in">protect</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> deathptr;</span><br><span class="line">    &#125; <span class="keyword">while</span> (deathptr != <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>通过源码方法实现解读的：</strong></p><ol><li><p><code>AutoreleasePoolPage</code>每个对象会开辟4096字节内存（虚拟内存一页的大小）</p></li><li><p>除了上面<code>AutoreleasePoolPageData</code>的实例变量（结构体的大小）所占空间，剩下的空间全部用来储存<code>autorelease</code>对象的地址</p><blockquote><p>（注意，<code>AutoreleasePoolPage</code>的第一页会包含哨兵对象，哨兵对象占位8字节，现每个加入的对象为8字节，那么第一页最多可以存储504个对象，从第二页开始最多可以存储505个对象。）</p></blockquote></li><li><p><code>AutoreleasepoolPage </code>通过压栈的方式来存储每个<code>autorelease</code>的对象(<font color=red>从低地址到高地址</font>)。</p></li><li><p><code>next</code>指针作为游标指向栈顶最新<code>add</code>进来的<code>autorelease</code>对象的下一个位置,</p><blockquote><p>当 <code>next</code>指针指向<code>begin</code>时，表示 <code>AutoreleasePoolPage </code>为空；</p><p>当 <code>next</code>指针指向<code>end</code>时，表示 <code>AutoreleasePoolPage</code> 已满;</p></blockquote></li><li><p>当向<code>AutoreleasePool</code>中新增<code>autorelease</code>对象时，底层<code>autoreleaseFast</code>函数内会：</p><ul><li>当前<code>AutoreleasePoolPage</code>没满：直接将该对象插入此page中</li><li>当前<code>AutoreleasePoolPage</code>满了：新建一个<code>AutoreleasePoolPage</code>对象(作为child，自然原来的page变成了parent)，并设置<code>child</code>为<code>hotPage</code>，<code>parent</code>为<code>coldPage</code>，将该对象插入hotPage中；</li><li>当前<code>AutoreleasePoolPage</code>为空：新建一个<code>AutoreleasePoolPage</code>对象，设置为hotPage，再将该对象插入hotPage中；</li></ul></li><li><p>当销毁Autoreleasepool时,Autoreleasepool::pop函数内会：</p><ul><li>根据哨兵对象获取目标page地址</li><li>通过root page拿到hotpage(),从hotPage的next指针开始向boundary之后的所有对象发送release消息</li><li>所有对象发完release消息之后，调用kill方法删除空page （memory: delete empty children）；</li></ul></li></ol><h1 id="6-AutoreleasePool的嵌套"><a href="#6-AutoreleasePool的嵌套" class="headerlink" title="6. AutoreleasePool的嵌套"></a>6. AutoreleasePool的嵌套</h1><p>查看两个嵌套的AutoreleasePool在内存中的结构：</p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">       for (int i = 0; i&lt;5; i++) &#123;</span><br><span class="line">           YLAnimal *tmpAni = [YLAnimal animal2];</span><br><span class="line">       &#125;</span><br><span class="line">       @autoreleasepool &#123;</span><br><span class="line">           for (int i = 0; i&lt;10; i++) &#123;</span><br><span class="line">               YLDog *tmpAni = [YLDog doggy2];</span><br><span class="line">           &#125;</span><br><span class="line">           _objc_autoreleasePoolPrint();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><img src="../images/内存管理-autoreleasepool_嵌套.png" alt="pool嵌套" style="zoom:80%;" /><p>其内部对象释放过程：</p><p>与单一autoreleasepool没有区别，主要是明白一点：<strong>任何释放池在释放时都是从内侧pool开始释放，不存在一个直接从外层pool开始的情况；</strong></p><p>以上面结构为例，一定是先释放boundary 2 所在的pool；然后才能轮到 boundary 1 的pool；当释放到boundary 1 pool时，bound 2pool已经被销毁了，所以最终释放的都是一个单层的pool；</p><p>总结：</p><ul><li>一个pool 有且只有一个boundary，但是可以有N个page</li><li>一个page内可能有1个、0个、多个boundary</li></ul><h1 id="TODO：7-哪些对象会自动加入autoreleasepool？"><a href="#TODO：7-哪些对象会自动加入autoreleasepool？" class="headerlink" title="TODO：7. 哪些对象会自动加入autoreleasepool？"></a>TODO：7. 哪些对象会自动加入autoreleasepool？</h1><img src="../images/内存管理-autorelease_汇编code.png" alt="pool嵌套" style="zoom:100%;" /><ul><li><strong>+(instancetype)自定义的的工厂方法创建的对象一定会加入到autoreleasepool中吗？</strong></li><li>alloc 的对象一定不会加到autoreleasepool中</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理--内存对齐</title>
      <link href="/blog/2021/08/14/nei-cun-guan-li-nei-cun-dui-qi/"/>
      <url>/blog/2021/08/14/nei-cun-guan-li-nei-cun-dui-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="TODO：内存对齐"><a href="#TODO：内存对齐" class="headerlink" title="TODO：内存对齐"></a>TODO：内存对齐</h2><h2 id="对象的本质"><a href="#对象的本质" class="headerlink" title="对象的本质"></a>对象的本质</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    NSObject *obj = [NSObject alloc];</span><br><span class="line">    NSLog(@&quot;%@&quot;,obj);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用clang查看一下以上代码中，NSObject被编译成了什么？</p><blockquote><h4 id="clang用法："><a href="#clang用法：" class="headerlink" title="clang用法："></a>clang用法：</h4><p>打开<strong>终端</strong>， cd 到指定的OC文件所在目录下，键入指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc 对应OC文件.m -o OC文件同名.cpp</span><br></pre></td></tr></table></figure><p>也可以指定架构，键入指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc 对应OC文件.m -o OC文件同名.cpp</span><br></pre></td></tr></table></figure></blockquote><img src="../images/内存对齐_NSObject_源码.jpg" alt="NSObject" style="zoom:80%;" /><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ol><li><p>NSObject对象的本质是什么？</p><p>答：本质是一个objc_Object的结构体，其成员变量只有一个isa指针；</p></li><li><p>一个NSObject对象占用多少内存空间？</p><p>答：一个NSObject对象的结构体中，只有isa一个成员，isa是指针类型。因此，在64位架构中，占用<strong>8个字节</strong>的内存。在这里，结构体中只有一个成员，所以isa的地址，就是结构体的地址，就是NSObject对象的地址。</p></li><li><p>一个自定义类的对象占用多大的内存空间？</p><p>答：</p></li><li></li></ol><h3 id="cache-t结构"><a href="#cache-t结构" class="headerlink" title="cache_t结构"></a>cache_t结构</h3><h2 id="alloc源码探索"><a href="#alloc源码探索" class="headerlink" title="alloc源码探索"></a>alloc源码探索</h2>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/blog/2021/08/11/nei-cun-guan-li-lei-yu-dui-xiang/"/>
      <url>/blog/2021/08/11/nei-cun-guan-li-lei-yu-dui-xiang/</url>
      
        <content type="html"><![CDATA[<p>title: 内存管理–类与对象<br>date: 2021-08-12<br>tags: ios</p><h2 id="OC中的三种对象："><a href="#OC中的三种对象：" class="headerlink" title="OC中的三种对象："></a>OC中的三种对象：</h2><ul><li>instance对象</li><li>class对象</li><li>meta-class对象</li></ul><h3 id="instance对象"><a href="#instance对象" class="headerlink" title="instance对象"></a>instance对象</h3><p>instance对象在内存中存储的信息  包括：</p><ul><li><p>isa指针</p></li><li><p>其他成员变量</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例对象：（堆区，初始化时指向它的指针在栈区）</span></span><br><span class="line">isa（前<span class="number">8</span>个字节）</span><br><span class="line">成员变量值</span><br><span class="line">…</span><br></pre></td></tr></table></figure></li></ul><h3 id="class对象"><a href="#class对象" class="headerlink" title="class对象"></a>class对象</h3><p>class对象在内存中存储的信息 主要包括：</p><ul><li>isa指针</li><li>superclass指针</li><li>类的属性信息（Property）</li><li>类的成员变量信息（Ivar）</li><li>对象方法信息（Instance Method）</li><li>类的协议信息（Protocol）</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类对象：（全局区）                               </span></span><br><span class="line">isa （前<span class="number">8</span>个字节</span><br><span class="line">superClass （第二个<span class="number">8</span>个字节）</span><br><span class="line">属性信息</span><br><span class="line">成员变量信息</span><br><span class="line">对象方法信息</span><br><span class="line">协议信息</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="meta-class对象"><a href="#meta-class对象" class="headerlink" title="meta-class对象"></a>meta-class对象</h3><p>meta-class对象在内存中存储的信息主要包括：</p><ul><li>isa指针</li><li>superclass指针</li><li>类方法信息（Class Method）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 类对象：（全局区）                               </span><br><span class="line">isa （前8个字节</span><br><span class="line">superClass （第二个8个字节）</span><br><span class="line">类方法信息</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h2 id="isa指向"><a href="#isa指向" class="headerlink" title="isa指向"></a>isa指向</h2><p>instance对象 —&gt; class对象 —-&gt; meta-class对象 —-&gt; NSObject(Meta) —-&gt; NSObject(Meta) 自己</p><p>🌰：person —&gt; YLPerson —-&gt; YLPerson(Meta) —-&gt; NSObject(Meta) —-&gt; NSObject(Meta) 自己</p><h2 id="super指向"><a href="#super指向" class="headerlink" title="super指向"></a>super指向</h2><p> 自定义class对象 —-&gt; NSObject —-&gt; nil</p><p>🌰：son —-&gt; YLPerson —-&gt; NSObject —-&gt; nil </p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h4 id="Objective-C中的动态类型和静态类型"><a href="#Objective-C中的动态类型和静态类型" class="headerlink" title="Objective-C中的动态类型和静态类型"></a>Objective-C中的动态类型和静态类型</h4><ul><li><p>动态类型</p><p>动态类型指的是对象指针类型的动态性，具体是指使用<code>id</code>修饰后将对象的类型确定推迟到运行时，由赋给它的对象类型决定对象指针的类型。也就是说<code>id</code>修饰的对象为动态类型对象，其他在编译器指明类型的为静态类型对象，通常如果不需要涉及到多态的话还是要尽量使用静态类型（原因：错误可以在编译器提前查出，可读性好）。</p></li><li><p>静态类型</p><p>一个指针变量指向特定类的对象时，使用的是静态类型，在编译的时候就知道这个指针变量所属的类。使用静态类型时，编译器在编译期间，会做许多的类型检查：因为编译器需要知道哪个对象该如何使用。</p></li></ul><h4 id="关联返回类型和非关联返回类型"><a href="#关联返回类型和非关联返回类型" class="headerlink" title="关联返回类型和非关联返回类型"></a>关联返回类型和非关联返回类型</h4><ul><li><p>关联返回类型涉及的方法</p><ul><li><p>类方法：以alloc、new 开头的</p></li><li><p>实例方法：以<code>autorelease</code>，<code>init</code>，<code>retain</code>或<code>self</code>开头</p><p>当这些方法返回值为<code>id</code>类型时，编译器不会返回一个类型不明的对象，会返回一个方法所在类类型的对象，这些方法就被称为是关联返回类型的方法。换句话说，这些方法的返回结果以方法所在的类为类型。</p><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface YLAnimal : NSObject</span><br><span class="line">  </span><br><span class="line">+ (id)newTestObject;  // 返回一个自动关联为YLAnimal类型的对象</span><br><span class="line">+ (id)allocTestObject;// 返回一个自动关联为YLAnimal类型的对象</span><br><span class="line">+ (id)testObject;// 返回一个类型不明的对象</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ul></li><li><p>非关联返回类型</p><ul><li>非以上关键字开头的方法,返回值不关联所属类的类型，会返回一个类型不明的对象</li></ul></li></ul><h3 id="id、instancetype、NSObject-的区别"><a href="#id、instancetype、NSObject-的区别" class="headerlink" title="id、instancetype、NSObject * 的区别"></a>id、instancetype、NSObject * 的区别</h3><p>答：</p><table><thead><tr><th>类型</th><th>使用范围</th><th>静态or动态</th></tr></thead><tbody><tr><td>id</td><td>* 定义变量； <br />* 定义方法返回值；<br />*  定义方法参数。</td><td>动态类型对象；<br />编译时编译器不会检查id对象的类型，<br />只有在运行时动态检查后会报错。<br /></td></tr><tr><td>instancetype</td><td>* 只可作为函数返回值</td><td>动态类型 <br/>（扩大关联返回类型的方法范围，<br>不再只是cocoa定义的特定关键字开头）<br />作用：可以使那些<font color="red"><strong>非关联返回类型</strong></font>的方法返回所在类的类型</td></tr><tr><td>NSObject *</td><td>* 定义变量； <br />* 定义方法返回值；<br />*  定义方法参数。</td><td>静态类型<br />编译时会进行类型检查。</td></tr><tr><td>id<NSObject> *</td><td></td><td>只要遵循<NSObject>协议的任何一种类型；</td></tr></tbody></table><h3 id="Todo-关于NSProxy与NSObject"><a href="#Todo-关于NSProxy与NSObject" class="headerlink" title="Todo : 关于NSProxy与NSObject"></a>Todo : 关于NSProxy与NSObject</h3><img src="../images/内存对齐_OC类与对象_NSObject.jpg" alt="NSobject" style="zoom:80%;" /><img src="../images/内存对齐_OC类与对象_NSProxy.jpg" style="zoom:80%;" />]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
