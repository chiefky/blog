<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Block</title>
      <link href="/blog/2021/08/27/block/"/>
      <url>/blog/2021/08/27/block/</url>
      
        <content type="html"><![CDATA[<h1 id="Block的三种类型"><a href="#Block的三种类型" class="headerlink" title="Block的三种类型"></a>Block的三种类型</h1><h3 id="三种类型特点："><a href="#三种类型特点：" class="headerlink" title="三种类型特点："></a>三种类型特点：</h3><p>(堆栈是在运行时分配空间，全局是在编译期就能确定)</p><ul><li>全局block<ul><li>位于全局区</li><li>在block内部不使用外部变量 or <strong>只使用</strong>全局变量或者静态变量</li></ul></li><li>堆区block<ul><li>位于堆区</li><li>前提：在block内部可以使用外部变量或OC属性，并且将block赋值给strong或copy修饰的变量</li></ul></li><li>栈区block<ul><li>位于栈区</li><li>前提：在block内部可以使用外部变量或OC属性，并且不对block赋值或者只能赋值给weak修饰的变量</li></ul></li></ul><p>举例说明：</p><img src="../assets/images/block_声明.png" alt="声明" style="zoom:80%;"><img src="../assets/images/block_类型_global.png" alt="全局区block" style="zoom:80%;"><img src="../assets/images/block_类型_malloc_statck.png" alt="堆区和栈区" style="zoom:80%;"><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol><li><p>以下代码将会怎样执行？换成注释中的代码又会怎样执行？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)testStackBlock_copy {</span><br><span class="line">    int num = 8;</span><br><span class="line">    void(^__weak weakBlock)(void) = nil;</span><br><span class="line">    {</span><br><span class="line">        void(^__weak weakBlock1)(void) = ^{</span><br><span class="line">            NSLog(@"num = %d",num);</span><br><span class="line">        };  </span><br><span class="line">        weakBlock = weakBlock1;// [weakBlock1 copy];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    weakBlock();</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>答： </p><p>1.” weakBlock = weakBlock1; “</p><p>两个block都是stack block，都存储在栈区；栈区空间是方法体空间，中间的’{}’表示匿名作用域，（C语言中介绍）栈存储期间匿名作用域的变量超出匿名作用域不一定立即释放；</p><pre><code> 2. "weakBlock = [weakBlock1 copy];"   经过copy后 weakBlock指向的是堆区的空间，在ARC下,编译器在匿名作用域"}"插入了release，weakBlock 指向的区域被自动释放，所以超出"}"调用weakBlock() 会崩溃。        </code></pre></blockquote></li><li><p>什么情况下系统不会对block执行copy操作？</p></li></ol><p>答：stack block作为函数参数时，系统无法判断是否需要进行copy，此时不会主动进行copy操作；</p><p>#2. block原理探索</p><h2 id="2-1-block的本质"><a href="#2-1-block的本质" class="headerlink" title="2.1 block的本质"></a>2.1 block的本质</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) {</span><br><span class="line">   </span><br><span class="line">    NSObject *obj = [NSObject alloc];</span><br><span class="line">    void (^ strBlock)(void) = ^{</span><br><span class="line">        NSLog(@"obj retainCount: %ld",CFGetRetainCount((__bridge CFTypeRef)obj));</span><br><span class="line">    };</span><br><span class="line">    strBlock();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>block代码经过编译生成的c++源码:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> {</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  NSObject *obj;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, NSObject *_obj, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="built_in">obj</span>(_obj) {</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) {</span><br><span class="line">  NSObject *obj = __cself-&gt;obj; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_kg_jwbbkd7s2zd3q3kqhq5x64wm0000gp_T_main_a63961_mi_5,<span class="built_in">CFGetRetainCount</span>((__bridge CFTypeRef)obj));</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;obj, (<span class="keyword">void</span>*)src-&gt;obj, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;obj, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> {</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">} __main_block_desc_0_DATA = { <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>{</span><br><span class="line"></span><br><span class="line">    NSObject *obj = ((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)<span class="built_in">objc_getClass</span>(<span class="string">"NSObject"</span>), <span class="built_in">sel_registerName</span>(<span class="string">"alloc"</span>));</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* strBlock)(<span class="keyword">void</span>) = ((<span class="built_in"><span class="keyword">void</span></span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, obj, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="built_in"><span class="keyword">void</span></span> (*)(__block_impl *))((__block_impl *)strBlock)-&gt;FuncPtr)((__block_impl *)strBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">void</span></span> (* strBlock)(<span class="keyword">void</span>) = ((<span class="built_in"><span class="keyword">void</span></span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, obj, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">((<span class="built_in"><span class="keyword">void</span></span> (*)(__block_impl *))((__block_impl *)strBlock)-&gt;FuncPtr)((__block_impl *)strBlock);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><img src="../assets/images/block_main_cpp.png" alt="main_cpp" style="zoom:80%;"><p>从上图看出:</p><ol><li><p>main函数中的strBlock被编译成了一个<code>__main_block_impl_0</code>的strut;</p></li><li><p><code>__main_block_impl_0</code> 结构体包含一个<code>__block_impl</code>结构体、一个<code>__main_block_desv_0</code>结构体和一个捕获的外部变量<code>obj</code>；</p><img src="../assets/images/block_imp.jpg" alt="bloc_imp" style="zoom:120%;"></li><li><p><code>__block_impl</code>结构体则包含一个isa、一个FuncPtr 和两个int类型标记；</p></li></ol><h3 id="如何查看Block类型？"><a href="#如何查看Block类型？" class="headerlink" title="如何查看Block类型？"></a>如何查看Block类型？</h3><p>（看👀–&gt; struct 的isa) 📢：这里只是编译成cpp代码的中间类型，经过汇编，如果会copy到堆区最终将修改成mallocblock</p><h2 id="2-2-block是怎样捕获外部变量的？"><a href="#2-2-block是怎样捕获外部变量的？" class="headerlink" title="2.2 block是怎样捕获外部变量的？"></a>2.2 block是怎样捕获外部变量的？</h2><p>对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的。也就是说block的自动变量截获只针对block内部使用的自动变量, 不使用则不截获, 因为截获的自动变量会存储于block的结构体内部, 会导致block体积变大。特别要注意的是默认情况下block只能访问不能修改局部变量的值。捕获变量分两种情况如下：</p><ul><li>非<code>__block</code>修饰的变量</li><li><code>__block</code>修饰的变量</li></ul><h3 id="2-2-1-捕获非-block修饰的变量"><a href="#2-2-1-捕获非-block修饰的变量" class="headerlink" title="2.2.1 捕获非__block修饰的变量"></a>2.2.1 捕获非<code>__block</code>修饰的变量</h3><h4 id="从内存管理语义角度考察"><a href="#从内存管理语义角度考察" class="headerlink" title="从内存管理语义角度考察"></a>从内存管理语义角度考察</h4><p>原则：遇强捕强遇弱捕弱</p><h4 id="从输出捕获变量值考察"><a href="#从输出捕获变量值考察" class="headerlink" title="从输出捕获变量值考察"></a>从输出捕获变量值考察</h4><ul><li><p>捕获外部变量(传递的是值)</p></li><li><p>捕获静态变量(传递的是静态变量的指针)</p></li><li><p>捕获全局变量（没有传递，直接访问的全局区）</p></li><li><p>捕获外部OC对象（传的是对象的值）</p><p>原因：<strong>为了保证block内部能够正常访问外部的变量，block有个变量捕获机制；auto变量age的block访问方式是值传递，static变量num的block访问方式是指针传递，block不需要对全局变量捕获，都是直接采用取全局变量的值</strong>。</p><img src="../assets/images/block_main_m_catch.png" alt="捕获变量" style="zoom:80%;"><img src="../assets/images/block_main_cpp_catch_2.png" alt="捕获变量编译源码解析2" style="zoom:80%;"><img src="../assets/images/block_main_cpp_catch_1.png" alt="捕获变量源码解析1" style="zoom:80%;"></li></ul><h3 id="2-2-2-捕获-block修饰的变量"><a href="#2-2-2-捕获-block修饰的变量" class="headerlink" title="2.2.2 捕获__block修饰的变量"></a>2.2.2 捕获<code>__block</code>修饰的变量</h3><p>对于用 <code>__block</code> 修饰的外部变量引用，block 是复制其引用地址来实现访问的。block可以修改__block 修饰的外部变量的值。</p><img src="../assets/images/block_main_cpp__block_2.png" alt="__block传指针" style="zoom:80%;"><img src="../assets/images/block_main_cpp__block_0.png" alt="__block传指针" style="zoom:100%;"><p>通过编译源码解析成的c代码，会发现加上<code>__block</code>修饰符的局部变量，竟然跟block一样变成了一个<code>__Block_byref_bmuArray_0</code>结构体类型变量实例！！！！</p><p>此时我们在block内部访问val变量则需要通过一个叫__forwarding的成员变量来间接访问val变量。</p><img src="../assets/images/block_main_cpp__block_1.png" alt="__block传指针" style="zoom:80%;"><h4 id="block变量与-forwarding"><a href="#block变量与-forwarding" class="headerlink" title="__block变量与__forwarding"></a><code>__block变量</code>与__forwarding</h4><img src="../assets/images/block_forwarding.png" alt="__forwording" style="zoom:80%;"><p>通过__forwarding, 无论是在block中还是 block外访问__block变量, 也不管该变量在栈上或堆上, 都能顺利地访问同一个__block变量。</p><h1 id="3-block内循环引用解决方案"><a href="#3-block内循环引用解决方案" class="headerlink" title="3. block内循环引用解决方案"></a>3. block内循环引用解决方案</h1><ul><li> 方案一：借助weak</li></ul>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)testBlockLifeCircle_weak {</span><br><span class="line">  __weak typeof(self) weakSelf = self;</span><br><span class="line"></span><br><span class="line">  self.yl_VBlock = ^{</span><br><span class="line">    NSLog(@"demoName = %@",[weakSelf demoName]);</span><br><span class="line">  };</span><br><span class="line">  self.yl_VBlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>方案二：借助__block</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)testBlockLifeCircle_block {</span><br><span class="line"></span><br><span class="line">  __block YLBlockRetainCycleViewController *tmpVC = self;</span><br><span class="line">  self.yl_VBlock = ^{</span><br><span class="line">    NSLog(@"demoName = %@",[tmpVC demoName]);</span><br><span class="line">    tmpVC = nil; // 📢：1.必须将变量置为nil</span><br><span class="line">  };</span><br><span class="line">  self.yl_VBlock(); // 📢：2.必须调用block(如果不调不会，解决循环引用)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p> 方案三：借助参数</p></li></ul>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)testBlockLifeCircle_Parameter {</span><br><span class="line">  self.yl_PBlock = ^(YLBlockRetainCycleViewController *vc) {</span><br><span class="line">    NSLog(@"demoName = %@",[vc demoName]);</span><br><span class="line">  };</span><br><span class="line">  self.yl_PBlock(self);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li> 方案四：使用NSProxy（其实是借助参数传递中间者+中间者弱持有self就可以解决，完全可以不用消息转发）（使用Proxy的原理是：1.添加了一个中间者Proxy；2.Proxy持有一个弱引用对象，也就是响应方法的目标对象；3. 借助消息转发机制将消息传递给目标对象）</li></ul>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)testBlockLifeCircle_Rroxy {</span><br><span class="line">  YLProxy *proxy = [YLProxy proxyWithTarget:self];</span><br><span class="line">  self.yl_PoxBlock = ^(YLProxy *pox) {</span><br><span class="line">    NSLog(@"demoName = %@",[pox.target demoName]);</span><br><span class="line">  };</span><br><span class="line">  self.yl_PoxBlock(proxy);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> block </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/2021/08/27/hello-world/"/>
      <url>/blog/2021/08/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内存布局-内存对齐</title>
      <link href="/blog/2018/09/07/nei-cun-guan-li-nei-cun-dui-qi/"/>
      <url>/blog/2018/09/07/nei-cun-guan-li-nei-cun-dui-qi/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><p><strong>C/C++各数据类型占用字节数(Byte)</strong></p><table><thead><tr><th>编译器类型</th><th>16位</th><th>32位</th><th>64位</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>1</td><td>1</td></tr><tr><td>short int</td><td>2</td><td>2</td><td>2</td></tr><tr><td>int</td><td>2</td><td>4</td><td>4</td></tr><tr><td>unsigned int</td><td>2</td><td>4</td><td>4</td></tr><tr><td>long</td><td>4</td><td>4</td><td>4</td></tr><tr><td>unsigned long</td><td>4</td><td>4</td><td>4</td></tr><tr><td>long long</td><td>8</td><td>8</td><td>8</td></tr><tr><td>float</td><td>4</td><td>4</td><td>4</td></tr><tr><td>double</td><td>8</td><td>8</td><td>8</td></tr><tr><td>指针</td><td>2</td><td>4</td><td>8</td></tr></tbody></table><p>附: </p><blockquote><p>32位的操作系统就是指：地址总线是32位的系统。那么，也就是说操作系统的位数决定了指针变量所占的字节数。</p></blockquote><h1 id="2-获取内存大小的三种方式"><a href="#2-获取内存大小的三种方式" class="headerlink" title="2. 获取内存大小的三种方式"></a>2. 获取内存大小的三种方式</h1><ul><li><p>sizeof</p><blockquote><p>1、<code>sizeof</code>是一个 <strong>操作符</strong>，不是函数</p><p>2、我们一般用sizeof计算内存大小时，<code>传入</code>的主要对象是<code>数据类型</code>，这个在编译器的<code>编译阶段</code>(即编译时)就会确定大小而不是在运行时确定。</p><p>3、<code>sizeof</code>最终得到的结果是该数据类型占用空间的大小</p></blockquote></li><li><p>**class_getInstanceSize **</p><p>计算对象实际占用的内存大小，这个需要依据类的属性而变化</p></li><li><p><strong>malloc_size</strong></p><p>对象系统分配的内存大小</p><table><thead><tr><th></th><th>区别</th><th>参数类型</th><th>用法</th></tr></thead><tbody><tr><td><strong>sizeof()</strong></td><td>终得到的结果是该数据类型占用空间的大小</td><td>基本数据类型、对象、指针</td><td>sizeof(Struct1）<br>sizeof(Int)</td></tr><tr><td><strong>class_getInstanceSize（）</strong></td><td>对象实际占用的内存大小</td><td>对象类型</td><td>class_getInstanceSize([NSObject  class])</td></tr><tr><td><strong>malloc_size（）</strong></td><td>系统分配的内存大小</td><td>__bridge指针类型</td><td>malloc_size((__bridge const void*)(obj))</td></tr></tbody></table></li></ul><h1 id="3-为什么要进行内存对齐"><a href="#3-为什么要进行内存对齐" class="headerlink" title="3. 为什么要进行内存对齐"></a>3. 为什么要进行内存对齐</h1><ol><li>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.</li><li>不同硬件平台不一定支持访问任意内存地址数据，使用内存对齐可以保证每次访问都从块内存地址头部开始存取</li><li>提高cpu内存访问速度，内存是分块的，如两字节一块，四字节一块，考虑这种情况：一个四字节变量存在一个四字节地址的后三位和下一个四字节地址的前一位，这样cpu从内存中取数据便需要访问两个内存并将他们组合起来，降低cpu性能</li></ol><blockquote><ul><li>通常内存是由一个个字节组成的，cpu在存取数据时，并不是以字节为单位存储，而是以块为单位存取，块的大小为内存存取力度。频繁存取字节未对齐的数据，会极大降低cpu的性能，所以可以通过减少存取次数来降低cpu的开销</li><li>16字节对齐，是由于在一个对象中，第一个属性isa占8字节，当然一个对象肯定还有其他属性，当无属性时，会预留8字节，即16字节对齐，如果不预留，相当于这个对象的isa和其他对象的isa紧挨着，容易造成访问混乱</li><li>16字节对齐后，可以加快CPU读取速度，同时使访问更安全，不会产生访问混乱的情况</li></ul></blockquote><h1 id="4-内存对齐原则"><a href="#4-内存对齐原则" class="headerlink" title="4. 内存对齐原则"></a>4. 内存对齐原则</h1><p><strong>内存字节对齐的原则，主要有以下三点：</strong></p><ol><li><p>数据成员对齐规则：struct 或者 union 的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如数据、结构体等）的整数倍开始（例如int在32位机中是4字节，则要从4的整数倍地址开始存储）</p><blockquote><p>index 的取值满足以下伪代码：</p><p>for（int x= offset; x++; x % currentIvarSize == 0 ） {</p><p>​      index = x; </p><p>}</p></blockquote></li><li><p>数据成员为结构体：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储（例如：struct a里面存有struct b，b里面有char、int、double等元素，则b应该从8的整数倍开始存储）</p></li><li><p>结构体的整体对齐规则：结构体的总大小，即sizeof的结果，必须是其内部做大成员的整数倍，不足的要补齐</p></li></ol><p><strong>实例🌰</strong></p><p>例子1（下标对齐）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Struct1 {</span><br><span class="line">    double a; // 8</span><br><span class="line">    int b; // 4</span><br><span class="line">    char c; // 1</span><br><span class="line">    short d; // 2</span><br><span class="line">}Struct1;</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th></th><th>a(8字节)</th><th>b（4字节）</th><th>c（1字节）</th><th>d（2字节）</th><th>末尾补齐</th></tr></thead><tbody><tr><td>对齐前</td><td>【0-7】</td><td>【8-11】</td><td>【12】</td><td>【13-14】</td><td></td></tr><tr><td>对齐后</td><td>【0-7】</td><td>【8-11】</td><td>【12】</td><td>下标13不可以整除2(原则第1条);对齐后是【14-15】</td><td>正好，不需要补</td></tr></tbody></table><p>例子2（下表对齐+总长度对齐）：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Struct2 {</span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">double</span> b; <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">int</span> c; <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">char</span> d; <span class="comment">// 1</span></span><br><span class="line">}Struct2;</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th></th><th>a(4字节)</th><th>b（8字节）</th><th>c（4字节）</th><th>d（1字节）</th><th>末尾补齐</th></tr></thead><tbody><tr><td>对齐前</td><td>【0-3】</td><td>【4-11】</td><td>【12-15】</td><td>【16】</td><td></td></tr><tr><td>对齐后</td><td>【0-3】</td><td>下标4不可以整除8(原则第1条);<br>对齐后是【8-15】</td><td>【16-19】</td><td>【20】</td><td>总长度必须是最大成员的整数倍(原则第3条)；<br>补齐末尾【21-23】</td></tr></tbody></table><p>例子3（）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//1、结构体嵌套结构体</span><br><span class="line">struct Struct3{</span><br><span class="line">    char a;   //1字节</span><br><span class="line">    int b;      //4字节</span><br><span class="line">    short c;    //2字节</span><br><span class="line">    double d;     //8字节</span><br><span class="line">    struct Struct2 str; </span><br><span class="line">}Struct3;</span><br><span class="line"></span><br><span class="line">//2、打印 Mystruct3 的内存大小</span><br><span class="line">NSLog(@"Mystruct3内存大小：%lu", sizeof(Mystruct3));</span><br><span class="line">NSLog(@"Mystruct3中结构体成员内存大小：%lu", sizeof(Mystruct3.str));</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th></th><th>a<br>(1字节)</th><th>b<br>（4字节）</th><th>c<br>（2字节）</th><th>d<br>（8字节）</th><th>str<br>（24字节）</th><th>末尾补齐</th></tr></thead><tbody><tr><td>对齐前</td><td>【0】</td><td>【1-4】</td><td>【5-6】</td><td>【7-14】</td><td>…..</td><td></td></tr><tr><td>对齐后</td><td>【0】</td><td>下标1不可以整除4(原则第1条);<br>对齐后是【4-7】</td><td>【8-9】</td><td>下标10不可以整除8(原则第1条);<br>【16-23】</td><td>【24-27】–a<br>【32-39】–b<br>【40-43】–c<br>【44】</td><td>总长度必须是最大成员的整数倍(原则第3条)；<br>补齐末尾【45-47】</td></tr></tbody></table><h1 id="TODO：5-内存优化（属性重排）"><a href="#TODO：5-内存优化（属性重排）" class="headerlink" title="TODO：5. 内存优化（属性重排）"></a>TODO：5. 内存优化（属性重排）</h1><p>待。。。。</p><h1 id="6-内存对齐算法"><a href="#6-内存对齐算法" class="headerlink" title="6. 内存对齐算法"></a>6. 内存对齐算法</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_SHIFT 3UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_MASK 7UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_BITS 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_SHIFT 2UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_MASK 3UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_BITS 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">word_align</span><span class="params">(<span class="keyword">uint32_t</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">word_align</span><span class="params">(<span class="keyword">size_t</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">align16</span><span class="params">(<span class="keyword">size_t</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (x + <span class="built_in">size_t</span>(<span class="number">15</span>)) &amp; ~<span class="built_in">size_t</span>(<span class="number">15</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>注意：</strong></p><ul><li>class_getInstanceSize（Class cls）：底层是8字节对齐</li><li>cls-&gt;instanceSize(extraBytes)：底层是16字节对齐</li></ul><p><strong>总结</strong></p><ul><li>在字节对齐算法中，对齐的主要是<code>对象</code>，而对象的本质则是一个 struct objc_object的<code>结构体</code>，</li><li><code>结构体</code>在内存中是<code>连续存放</code>的，所以可以利用这点对结构体进行强转。</li><li>苹果早期是<code>8</code>字节对齐，<code>现在</code>是<code>16字节对齐</code></li></ul><p>下面以<code>align（8） 为例，</code>图解16字节对齐算法的计算过程，如下所示</p><p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92677025d2674fd0b3c0996b89e6b08c~tplv-k3u1fbpfcp-watermark.awebp" alt="16字节对齐算法图解"></p><ul><li>首先将原始的内存 <code>8</code> 与 <code>size_t(15)</code>相加，得到 8 + 15 = 23</li><li>将 <code>size_t(15)</code> 即 15进行<code>~（取反）</code>操作，<code>~（取反）</code>的规则是：<code>1变为0，0变为1</code></li><li>最后将 23 与 15的取反结果 进行 <code>&amp;（与）</code>操作，<code>&amp;（与）</code>的规则是：<code>都是1为1，反之为0</code>，最后的结果为 16，即内存的大小是以<code>16</code>的倍数增加的</li></ul><p>链接：<a href="https://juejin.cn/post/6949576678205030431">https://juejin.cn/post/6949576678205030431</a></p><h1 id="7-面试题"><a href="#7-面试题" class="headerlink" title="7. 面试题"></a>7. 面试题</h1><ol><li><p>一个NSObject对象占用多少内存空间？（问的是实际占用空间，不是系统分配空间）</p><p>答：一个NSObject对象的结构体中，只有isa一个成员，isa是指针类型。因此，在64位架构中，占用<strong>8个字节</strong>的内存。在这里，结构体中只有一个成员，所以isa的地址，就是结构体的地址，就是NSObject对象的地址。</p></li><li><p>一个自定义类的对象占用多大的内存空间？</p><p>答：isa(8字节) + 各变量占用空间</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理</title>
      <link href="/blog/2018/09/07/nei-cun-guan-li/"/>
      <url>/blog/2018/09/07/nei-cun-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="1-内存布局（内存分区）"><a href="#1-内存布局（内存分区）" class="headerlink" title="1. 内存布局（内存分区）"></a>1. 内存布局（内存分区）</h1><p>共享库（libobjc.A.dylib等）与内核空间的内存布局在栈区之上;如下图：</p><img src="/Users/tangh/yuki/iOS练习Demos/YLNote/YLNote/latest/个人笔记/文章/images/内存布局_0.jpg" alt="内存分布" style="zoom:100%;"><ul><li><p><strong>内核区</strong>：用于加载内核代码，预留1GB</p></li><li><p><strong>共享区：用于加载系统库，例如:libobjc.a.dylib</strong></p></li><li><p><strong>栈区</strong>：创建临时变量时由编译器自动分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。栈区的内存地址一般是0x7开头,从高地址到底地址分配内存空间（**<font color="red">TaggedPointer</font>**）</p></li><li><p><strong>堆区</strong>：那些由 new alloc 创建的对象所分配的内存块，它们的释放系统不会主动去管，由我们的开发者去告诉系统什么时候释放这块内存(一个对象引用计数为0是系统就会回销毁该内存区域对象)。一般一个 new 就要对应一个release。在ARC下编译器会自动在合适位置为OC对象添加release操作。会在当前线程Runloop退出或休眠时销毁这些对象，MRC则需程序员手动释放。堆可以动态地扩展和收缩。堆区的内存地址一般是0x6开头,从底地址到高地址分配内存空间</p></li><li><p><strong>未初始化数据（静态区）</strong>：BSS段又称静态区，未初始化的全局变量，静态变量存放在这里。一旦初始化就会被回收，并且将数据转存到数据段中。</p></li><li><p><strong>已初始化数据（常量区）</strong>：数据段又称常量区，专门存放常量，直到程序结束的时候才会被回收</p></li><li><p><strong>代码段</strong>：用于存放程序运行时的代码，代码会被编译成二进制存进内存的程序代码区。程序结束时系统会自动回收存储在代码段中的数据。</p></li><li><p><strong>保留区</strong>：内存有4MB保留，地址从低到高递增</p><p>如何查看对象地址：</p><img src="../assets/images/内存布局_1.jpg" alt="内存分布-1" style="zoom:80%;"></li></ul><h1 id="2-内存管理方案"><a href="#2-内存管理方案" class="headerlink" title="2. 内存管理方案"></a>2. 内存管理方案</h1><ul><li><p>堆区：由开发者（借助<font color="red">引用计数</font>）管理的，需要告诉系统什么时候释放内存。</p><p>ARC下：编译器会自动在合适的时候插入引用计数管理代码（<code>retain</code>、<code>release</code>、<code>autorelease</code>）；</p><p>MRC下：需要开发者手动释放。</p></li><li><p>栈区、其他区：编译器自动分配，由系统管理，在不需要的时候自动清除；</p></li></ul><h1 id="3-引用计数原理"><a href="#3-引用计数原理" class="headerlink" title="3. 引用计数原理"></a>3. 引用计数原理</h1><p>引用计数是一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的<strong>被引用次数</strong>保存起来，当被引用次数<strong>变为零</strong>时就将其<strong>释放</strong>的过程。使用引用计数技术可以实现自动资源管理的目的。同时引用计数还可以指使用引用计数技术回收未使用资源的垃圾回收算法。</p><h2 id="3-1-引用计数规则"><a href="#3-1-引用计数规则" class="headerlink" title="3.1 引用计数规则"></a>3.1 引用计数规则</h2><ol><li>自己生成的对象，自己持有。（alloc,new,copy,mutableCopy等）</li><li>非自己生成的对象，自己也能持有。（retain 等）</li><li>不再需要自己持有的对象时释放。（release，dealloc 等）</li><li>非自己持有的对象无法释放。</li></ol><h2 id="3-2-alloc引起引用计数-1-的原因"><a href="#3-2-alloc引起引用计数-1-的原因" class="headerlink" title="3.2 alloc引起引用计数+1 的原因"></a>3.2 alloc引起引用计数+1 的原因</h2><p>答案看源码：</p><img src="../assets/images/内存管理_retaincount_alloc2.png" alt="retaincount" style="zoom:80%;"><img src="../assets/images/内存管理_retaincount_alloc1.png" alt="retaincount" style="zoom:80%;"><h1 id="4-Autoreleasepool"><a href="#4-Autoreleasepool" class="headerlink" title="4. Autoreleasepool"></a>4. Autoreleasepool</h1><h2 id="4-1-什么是Autoreleasepool"><a href="#4-1-什么是Autoreleasepool" class="headerlink" title="4.1 什么是Autoreleasepool?"></a>4.1 什么是Autoreleasepool?</h2><p>自动释放池是 <code>Objective-C</code> 开发中的一种自动内存回收管理的机制，为了替代开发人员手动管理内存，实质上是使用编译器在适当的位置插入<code>release</code>、<code>autorelease</code>等内存释放操作。当对象调用 <code>autorelease </code>方法后会被放到自动释放池中延迟释放时机，当缓存池需要清除<code>dealloc</code>时，会向这些 <code>Autoreleased </code>对象做 <code>release</code> 释放操作。</p><h2 id="4-2-对象什么时候释放"><a href="#4-2-对象什么时候释放" class="headerlink" title="4.2 对象什么时候释放"></a>4.2 对象什么时候释放</h2><p>以下A、B两种情况person分别什么时候释放(dealloc触发时机)？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// A:</span><br><span class="line">__weak id temp = nil;</span><br><span class="line">{</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    temp = person;</span><br><span class="line">}</span><br><span class="line">// 插入的release操作</span><br><span class="line"> // call void @llvm.objc.storeStrong(i8** %19, i8* null) #3  ----retainCount == 0，dealloc</span><br><span class="line">// 插入NSLog 传入weak变量操作</span><br><span class="line"> // %20 = call i8* @llvm.objc.loadWeakRetained(i8** %6) #3</span><br><span class="line">NSLog(@"temp = %@",temp);</span><br><span class="line">// 插入 weak release和destory</span><br><span class="line"> // call void @llvm.objc.release(i8* %20) #3, !clang.imprecise_release !10</span><br><span class="line"> // call void @llvm.objc.destroyWeak(i8** %6) #3</span><br><span class="line"> // call void @llvm.objc.autoreleasePoolPop(i8* %10)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>答案：</p><blockquote><p>先打印： [person dealloc]</p><p>后打印： temp = （null）</p><p>retainCount 减到0，立即释放，触发dealloc</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// B:</span><br><span class="line"></span><br><span class="line">+(instancetype)defaultPerson</span><br><span class="line">{</span><br><span class="line">    return [[Person alloc] init];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">__weak id temp = nil;</span><br><span class="line">{</span><br><span class="line">    Person *person = [Person defaultPerson]; </span><br><span class="line">   // %16 = notail call i8* @llvm.objc.retainAutoreleasedReturnValue(i8* %14) #3 ----retainCount == 2，retainAutoreleasedReturnValue中调了objc_retain(obj);</span><br><span class="line"></span><br><span class="line">    temp = person;</span><br><span class="line">}</span><br><span class="line"> // call void @llvm.objc.storeStrong(i8** %21, i8* null) #3 ----retainCount == 1，延迟释放</span><br><span class="line"> // %22 = call i8* @llvm.objc.loadWeakRetained(i8** %6) #3</span><br><span class="line">//  invoke void (i8*, ...) @NSLog(i8* bitcast (%struct.__NSConstantString_tag* @_unnamed_cfstring_.35 to i8*), i8* %22) to label %23 unwind label %24</span><br><span class="line">NSLog(@"temp = %@",temp);</span><br><span class="line">//   call void @llvm.objc.release(i8* %22) #3, !clang.imprecise_release !10</span><br><span class="line">//  call void @llvm.objc.destroyWeak(i8** %6) #3</span><br><span class="line">//  call void @llvm.objc.autoreleasePoolPop(i8* %10)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>答案：</p><blockquote><p>先打印： temp = <strong>&lt;Person: 0x10133d460&gt;</strong></p><p>后打印： [person dealloc]</p><p>retainCount减到1，对象延迟释放，等到autoreleasepool pop时，向pool内的对象发realse消息减到0才释放；</p></blockquote><h2 id="4-3-AutoreleasePool的使用"><a href="#4-3-AutoreleasePool的使用" class="headerlink" title="4.3 AutoreleasePool的使用"></a>4.3 AutoreleasePool的使用</h2><p><strong>初始化or创建</strong></p><p>MRC下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//1.生成一个NSAutoreleasePool对象</span><br><span class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">//2.创建对象</span><br><span class="line">id object = [[NSObject alloc] init];</span><br><span class="line">//3.对象调用autorelease方法</span><br><span class="line">[object autorelease];</span><br><span class="line">//4.废弃NSAutoreleasePool对象，会对释放池中的object发送release消息</span><br><span class="line">[pool drain];</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>ARC:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool {</span><br><span class="line">    //LLVM会在内部插入autorelease方法</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="TODO-面试题："><a href="#TODO-面试题：" class="headerlink" title="TODO: 面试题："></a>TODO: 面试题：</h3><p>以下代码有什么区别吗？</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YLAnimal</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc {</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">}</span><br><span class="line">+ (<span class="keyword">instancetype</span>)animal {</span><br><span class="line">  YLAnimal *ani = [YLAnimal alloc];</span><br><span class="line">  <span class="keyword">return</span> ani;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="keyword">@autoreleasepool</span> {</span><br><span class="line">  __<span class="keyword">weak</span> <span class="keyword">id</span> temp = <span class="literal">nil</span>;</span><br><span class="line">  {</span><br><span class="line">    YLAnimal *animal = [[YLAnimal alloc] init];</span><br><span class="line">    temp = animal;</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"temp = %@"</span>,temp);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="keyword">@autoreleasepool</span> {</span><br><span class="line">  __<span class="keyword">weak</span> <span class="keyword">id</span> temp = <span class="literal">nil</span>;</span><br><span class="line">  {</span><br><span class="line">      YLAnimal *animal = [YLAnimal animal];</span><br><span class="line">      temp = animal;</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"temp = %@"</span>,temp);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>答：<code>alloc</code>方法初始化 的animal不会加入到autoreleasepool中，超出作用域后，retaincount减为0，立即释放；</p><p><code>anima</code>方法初始化的animal会加入到autoreleasepool中，超出作用域后，延迟到autoreleasepool pop，才会释放;</p><blockquote><p>引申：</p><p>加入到autoreleasepool的对象一定会释放吗？</p><p>答：不一定，autoreleasepool销毁时只是对其内部对象发送release消息，引用计数减1，此时若对象的引用计数减完后不为0，就不会被释放，也就是所谓的内存泄漏。</p><p>引发内存泄漏的情况有哪些？</p><ul><li>循环引用：<ul><li>block</li><li>A –&gt; B –&gt; A</li><li>A –&gt; B –&gt; C –&gt; A</li><li>NSObserver center (<font color="red">待补充</font>) </li></ul></li><li>NSObserver center (<font color="red">待补充</font>) </li><li></li></ul></blockquote><h2 id="4-4-ARC下-autoreleasepool-被编译成了什么"><a href="#4-4-ARC下-autoreleasepool-被编译成了什么" class="headerlink" title="4.4  ARC下@autoreleasepool {} 被编译成了什么"></a>4.4  ARC下<code>@autoreleasepool {} </code>被编译成了什么</h2><p>使用clang命令将main.m编译成main.cpp，查看相关代码，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译前：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>{</span><br><span class="line">    @autoreleasepool {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>{</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> { __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可见，编译后把<code>@autoreleasePool</code>转换成一个<code>__AtAutoreleasePool </code>类型的局部私有变量<code>__AtAutoreleasePool __autoreleasepool</code>;然后查看一下<code>__AtAutoreleasePool</code>是什么？</p><p>对应main.cpp文件，main函数前面有<code>__AtAutoreleasePool</code>源码结构，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> {</span></span><br><span class="line">  __AtAutoreleasePool() {atautoreleasepoolobj = <span class="built_in">objc_autoreleasePoolPush</span>();}</span><br><span class="line">  ~__AtAutoreleasePool() {<span class="built_in">objc_autoreleasePoolPop</span>(atautoreleasepoolobj);}</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><code>__AtAutoreleasePool</code>是结构体类型，其内包含：</p><ul><li>构造函数<code>__AtAutoreleasePool()</code></li><li>析构函数<code>~__AtAutoreleasePool(atautoreleasepoolobj)</code>。</li><li>atautoreleasepoolobj (就是我们常说的<code>POOL_BOUNDARY</code>桩对象，析构时，以此对象为参照物向此对象之后插入的对象全部发送release消息)</li></ul><p>关于<code>@autoreleasepool</code>就这些，接下来是<code>objc_autoreleasePoolPush()</code> 、<code>objc_autoreleasePoolPop(obj)</code>的实现，即关于<code>AutoreleasepoolPage</code>的探索；</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::<span class="built_in">push</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">NEVER_INLINE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    AutoreleasePoolPage::<span class="built_in">pop</span>(ctxt);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="5-AutoreleasepoolPage"><a href="#5-AutoreleasepoolPage" class="headerlink" title="5. AutoreleasepoolPage"></a>5. AutoreleasepoolPage</h1><h2 id="5-1-内存结构"><a href="#5-1-内存结构" class="headerlink" title="5.1 内存结构"></a>5.1 内存结构</h2><h3 id="AutoreleasepoolPage在内存中以双向链表形式存在，如图："><a href="#AutoreleasepoolPage在内存中以双向链表形式存在，如图：" class="headerlink" title="AutoreleasepoolPage在内存中以双向链表形式存在，如图："></a>AutoreleasepoolPage在内存中以双向链表形式存在，如图：</h3><p><img src="../assets/images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-AutoreleasePoolPage_0.png" alt="双向链表"></p><h3 id="单个page的内存形态"><a href="#单个page的内存形态" class="headerlink" title="单个page的内存形态"></a>单个page的内存形态</h3><img src="../assets/images/内存管理-autoreleasepage_1.png" alt="AutoreleasepoolPage" style="zoom:80%;"><p><code>next</code> 指向了下一个为空的内存地址，如果 <code>next</code> 指向的地址加入一个 <code>object</code>，它就会如下图所示<strong>移动到下一个为空的内存地址中</strong>：</p><blockquote><p>注意：各变量在内存中的位置；</p></blockquote><h2 id="5-2-AutoreleasePoolPage部分关键源码"><a href="#5-2-AutoreleasePoolPage部分关键源码" class="headerlink" title="5.2  AutoreleasePoolPage部分关键源码"></a>5.2  AutoreleasePoolPage部分关键源码</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> :</span> <span class="keyword">private</span> AutoreleasePoolPageData</span><br><span class="line">{</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">thread_data_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE =</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">PAGE_MIN_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> COUNT = SIZE / <span class="built_in"><span class="keyword">sizeof</span></span>(id);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> MAX_FAULTS = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is </span></span><br><span class="line">    <span class="comment">// pushed and it has never contained any objects. This saves memory </span></span><br><span class="line">    <span class="comment">// when the top level (i.e. libdispatch) pushes and pops pools but </span></span><br><span class="line">    <span class="comment">// never uses them.</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> POOL_BOUNDARY nil</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AutoreleasePoolPage</span>(AutoreleasePoolPage *newParent) :</span><br><span class="line"><span class="built_in">AutoreleasePoolPageData</span>(<span class="built_in">begin</span>(),</span><br><span class="line"><span class="built_in">objc_thread_self</span>(),</span><br><span class="line">newParent,</span><br><span class="line">newParent ? <span class="number">1</span>+newParent-&gt;depth : <span class="number">0</span>,</span><br><span class="line">newParent ? newParent-&gt;hiwat : <span class="number">0</span>){ }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">AutoreleasePoolPage</span>(){}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function">id *<span class="title">add</span><span class="params">(id obj)</span></span>{}</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> AutoreleasePoolPage *<span class="title">hotPage</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setHotPage</span><span class="params">(AutoreleasePoolPage *page)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">static</span> <span class="keyword">inline</span> AutoreleasePoolPage *<span class="title">coldPage</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    .</span></span><br><span class="line"><span class="function">    .</span></span><br><span class="line"><span class="function">    .</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">}</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AutoreleasePoolPageData</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_AUTORELEASEPOOL_DEDUP_PTRS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AutoreleasePoolEntry</span> {</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> ptr: <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> count: <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uintptr_t</span> maxCount = <span class="number">65535</span>; <span class="comment">// 2^16 - 1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>((AutoreleasePoolEntry){ .ptr = MACH_VM_MAX_ADDRESS }.ptr == MACH_VM_MAX_ADDRESS, <span class="string">"MACH_VM_MAX_ADDRESS doesn't fit into AutoreleasePoolEntry::ptr!"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">magic_t</span> <span class="keyword">const</span> magic; <span class="comment">//用来校验 `AutoreleasePoolPage`的结构是否完整；16</span></span><br><span class="line">__unsafe_unretained id *next; <span class="comment">//指向最新添加的 `autoreleased` 对象的下一个位置，初始化时指向  `begin()` ；8</span></span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;  <span class="comment">//指向当前线程；8</span></span><br><span class="line">AutoreleasePoolPage * <span class="keyword">const</span> parent;    <span class="comment">//指向父结点，第一个结点的 `parent` 值为 `nil` ；8</span></span><br><span class="line">AutoreleasePoolPage *child;     <span class="comment">//指向子结点，最后一个结点的 `child` 值为 `nil` ；8</span></span><br><span class="line"><span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;  <span class="comment">//代表深度，从 `0` 开始，往后递增 `1`；4</span></span><br><span class="line"><span class="keyword">uint32_t</span> hiwat; <span class="comment">//代表 `high water mark` ; 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AutoreleasePoolPageData</span>(__unsafe_unretained id* _next, <span class="keyword">pthread_t</span> _thread, AutoreleasePoolPage* _parent, <span class="keyword">uint32_t</span> _depth, <span class="keyword">uint32_t</span> _hiwat)</span><br><span class="line">: <span class="built_in">magic</span>(), <span class="built_in">next</span>(_next), <span class="built_in">thread</span>(_thread),</span><br><span class="line">  <span class="built_in">parent</span>(_parent), <span class="built_in">child</span>(nil),</span><br><span class="line">  <span class="built_in">depth</span>(_depth), <span class="built_in">hiwat</span>(_hiwat)</span><br><span class="line">{</span><br><span class="line">}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>通过源码直观可见：</strong></p><ol><li><code>AutoreleasePoolPage</code>是继承自<code>AutoreleasePoolPageData</code>。</li><li><code>AutoreleasePoolPageData</code>有一个parent、一个child变量，分别是一个<code>AutoreleasePoolPage</code>指针。</li><li>每一个<code>AutoreleasePoolPageData</code>都对应一个pthread_t线程</li><li><code>AutoreleasePoolPageData</code>结构体的大小为56字节</li></ol><h3 id="5-2-1-AutoreleasePoolPage-push"><a href="#5-2-1-AutoreleasePoolPage-push" class="headerlink" title="5.2.1 AutoreleasePoolPage::push()"></a>5.2.1 AutoreleasePoolPage::push()</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        id *dest;</span><br><span class="line">          <span class="comment">//判断是否已经初始化AutoreleasePoolPage，slowpath()为小概率发生事件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">slowpath</span>(DebugPoolAllocation)) {</span><br><span class="line">            <span class="comment">// Each autorelease pool starts on a new pool page.</span></span><br><span class="line">            dest = <span class="built_in">autoreleaseNewPage</span>(POOL_BOUNDARY); </span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            dest = <span class="built_in">autoreleaseFast</span>(POOL_BOUNDARY);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// ⬆️ 这里的POOL_BOUNDARY就是我们常说的哨兵对象</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="关于”autoreleaseFast”核心方法的概括："><a href="#关于”autoreleaseFast”核心方法的概括：" class="headerlink" title="关于”autoreleaseFast”核心方法的概括："></a>关于”autoreleaseFast”核心方法的概括：</h5><ul><li><p>autoreleaseFullPage() ; // hotpage已满: 如果子页面存在，则将页面替换为子页面;不存在，则创建新页面</p></li><li><p>autoreleaseNoPage()；// hotpage不存在;</p><blockquote><p>第一步：先判断“是否有空占位符”，然后该标记标记，该报错报错，该返回empty pool placeholder返回empty pool placeholder；</p><p>第二步：确保占位符状态ok，且已经有了boundary，然后初始化一个page，并设置为hotPage；</p><p>第三步：page和占位符都就绪，先插入boundry对象，再add(obj)</p></blockquote></li><li><p>add(obj）；// hotpage存在，且未满：将当前对象加入pool中；(疑问❓ 这里返回的是谁的指针)</p></li></ul><h4 id="autoreleaseNewPage-方法–小概率发生事件"><a href="#autoreleaseNewPage-方法–小概率发生事件" class="headerlink" title="autoreleaseNewPage()方法–小概率发生事件"></a>autoreleaseNewPage()方法–小概率发生事件</h4><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __attribute__((noinline))</span><br><span class="line"><span class="function">id *<span class="title">autoreleaseNewPage</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//获取当前hotpage</span></span><br><span class="line">    AutoreleasePoolPage *page = <span class="built_in">hotPage</span>();</span><br><span class="line">    <span class="comment">//判断当前页是否存在，如果存在，则压栈对象</span></span><br><span class="line">    <span class="keyword">if</span> (page) <span class="keyword">return</span> <span class="built_in">autoreleaseFullPage</span>(obj, page);</span><br><span class="line">    <span class="comment">//如果不存在，则创建page</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">autoreleaseNoPage</span>(obj);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></blockquote><h4 id="autoreleaseFast-方法–大概率发生事件"><a href="#autoreleaseFast-方法–大概率发生事件" class="headerlink" title="autoreleaseFast()方法–大概率发生事件"></a>autoreleaseFast()方法–大概率发生事件</h4><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    AutoreleasePoolPage *page = <span class="built_in">hotPage</span>();</span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;<span class="built_in">full</span>()) {</span><br><span class="line">        <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (page) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">autoreleaseFullPage</span>(obj, page);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">autoreleaseNoPage</span>(obj);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></blockquote><h6 id="autoreleaseFullPage-方法"><a href="#autoreleaseFullPage-方法" class="headerlink" title="autoreleaseFullPage() 方法"></a>autoreleaseFullPage() 方法</h6><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> __attribute__((noinline))</span><br><span class="line"><span class="function">id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// The hot page is full. </span></span><br><span class="line">    <span class="comment">// Step to the next non-full page, adding a new page if necessary.</span></span><br><span class="line">    <span class="comment">// Then add the object to that page.</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(page == <span class="built_in">hotPage</span>());</span><br><span class="line">    <span class="built_in">ASSERT</span>(page-&gt;<span class="built_in">full</span>()  ||  DebugPoolAllocation);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历循环查找page是否已满</span></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="comment">//如果子页面存在，则将页面替换为子页面</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="comment">//如果子页面不存在，则创建新页面</span></span><br><span class="line">        <span class="keyword">else</span> page = <span class="keyword">new</span> <span class="built_in">AutoreleasePoolPage</span>(page);</span><br><span class="line">    } <span class="keyword">while</span> (page-&gt;<span class="built_in">full</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置为当前hotPage</span></span><br><span class="line">    <span class="built_in">setHotPage</span>(page);</span><br><span class="line">    <span class="comment">//对象压栈</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="autoreleaseNoPage-方法"><a href="#autoreleaseNoPage-方法" class="headerlink" title="autoreleaseNoPage()方法"></a>autoreleaseNoPage()方法</h6><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __attribute__((noinline))</span><br><span class="line"><span class="function">id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// "No page" could mean no pool has been pushed</span></span><br><span class="line">    <span class="comment">// or an empty placeholder pool has been pushed and has no contents yet</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(!<span class="built_in">hotPage</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> pushExtraBoundary = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//判断是否是空占位符，如果是，则压栈哨兵标识符置为YES</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">haveEmptyPoolPlaceholder</span>()) {</span><br><span class="line">        pushExtraBoundary = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//如果对象不是哨兵对象，且没有Pool，则报错</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) {</span><br><span class="line">        _objc_inform(<span class="string">"MISSING POOLS: (%p) Object %p of class %s "</span></span><br><span class="line">                     <span class="string">"autoreleased with no pool in place - "</span></span><br><span class="line">                     <span class="string">"just leaking - break on "</span></span><br><span class="line">                     <span class="string">"objc_autoreleaseNoPool() to debug"</span>, </span><br><span class="line">                     <span class="built_in">objc_thread_self</span>(), (<span class="keyword">void</span>*)obj, <span class="built_in">object_getClassName</span>(obj));</span><br><span class="line">        <span class="built_in">objc_autoreleaseNoPool</span>(obj);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//如果对象是哨兵对象，且没有申请自动释放池内存，则设置一个空占位符存储在tls中，其目的是为了节省内存</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) {</span><br><span class="line">        <span class="comment">// We are pushing a pool with no pool in place,</span></span><br><span class="line">        <span class="comment">// and alloc-per-pool debugging was not requested.</span></span><br><span class="line">        <span class="comment">// Install and return the empty pool placeholder.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setEmptyPoolPlaceholder</span>();<span class="comment">//设置空的占位符</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are pushing an object or a non-placeholder'd pool.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install the first page.</span></span><br><span class="line">    <span class="comment">//初始化第一页</span></span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">new</span> <span class="built_in">AutoreleasePoolPage</span>(nil);</span><br><span class="line">    <span class="comment">//设置page为当前hotpage</span></span><br><span class="line">    <span class="built_in">setHotPage</span>(page);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Push a boundary on behalf of the previously-placeholder'd pool.</span></span><br><span class="line">    <span class="comment">//压栈哨兵的标识符为YES，则压栈哨兵对象</span></span><br><span class="line">    <span class="keyword">if</span> (pushExtraBoundary) {</span><br><span class="line">        <span class="comment">//压栈哨兵</span></span><br><span class="line">        page-&gt;<span class="built_in">add</span>(POOL_BOUNDARY);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Push the requested object or pool.</span></span><br><span class="line">    <span class="comment">//压栈对象</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="add-obj-方法"><a href="#add-obj-方法" class="headerlink" title="add(obj)方法"></a>add(obj)方法</h6><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id *<span class="title">add</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">full</span>());</span><br><span class="line">    <span class="built_in">unprotect</span>();</span><br><span class="line">    id *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></span><br><span class="line">    *next++ = obj;</span><br><span class="line">    <span class="built_in">protect</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-2-AutoreleasePoolPage-pop"><a href="#5-2-2-AutoreleasePoolPage-pop" class="headerlink" title="5.2.2 AutoreleasePoolPage::pop()"></a>5.2.2 AutoreleasePoolPage::pop()</h3><img src="../assets/images/内存管理-autoreleasepage_pop_0.png" alt="pop-0" style="zoom:80%;"><img src="../assets/images/内存管理-autoreleasepage_pop_1.png" alt="pop-1" style="zoom:80%;"><img src="../assets/images/内存管理-autoreleasepage_pop_2.png" alt="pop-2" style="zoom:80%;"><h5 id="其中核心三步："><a href="#其中核心三步：" class="headerlink" title="其中核心三步："></a>其中核心三步：</h5><ul><li>pageForPointer(token); 根据传入的哨兵对象的地址，取得哨兵对象所在的page地址；</li><li>releaseUntil(stop); 拿hotPage逐一减1，直到page的next指向boundary；</li><li>page-&gt;kill(); 方法删除双向链表中的每一个page</li></ul><h4 id="pageForPointer-方法-—-根据哨兵对象找到page"><a href="#pageForPointer-方法-—-根据哨兵对象找到page" class="headerlink" title="pageForPointer( ) 方法 —- 根据哨兵对象找到page"></a>pageForPointer( ) 方法 —- 根据哨兵对象找到page</h4><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> AutoreleasePoolPage *<span class="title">pageForPointer</span><span class="params">(<span class="keyword">uintptr_t</span> p)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    AutoreleasePoolPage *result;</span><br><span class="line">    <span class="keyword">uintptr_t</span> offset = p % SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT</span>(offset &gt;= <span class="built_in"><span class="keyword">sizeof</span></span>(AutoreleasePoolPage));</span><br><span class="line"></span><br><span class="line">    result = (AutoreleasePoolPage *)(p - offset);</span><br><span class="line">    result-&gt;<span class="built_in">fastcheck</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解读：</p><ol><li>哨兵对象地址与页面size(4096)取模—&gt;哨兵对象的偏移量</li><li>根据哨兵对象的地址减偏移量便可以得到根page的首地址—&gt;哨兵对象所在page页</li></ol></blockquote><h4 id="releaseUntil-stop-方法-—-释放对象"><a href="#releaseUntil-stop-方法-—-释放对象" class="headerlink" title="releaseUntil(stop)方法 —- 释放对象"></a>releaseUntil(stop)方法 —- 释放对象</h4><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseUntil</span><span class="params">(id *stop)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Not recursive: we don't want to blow out the stack </span></span><br><span class="line">    <span class="comment">// if a thread accumulates a stupendous amount of garbage</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放AutoreleasePoolPage中的对象，直到next指向stop</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) {</span><br><span class="line">        <span class="comment">// Restart from hotPage() every time, in case -release </span></span><br><span class="line">        <span class="comment">// autoreleased more objects</span></span><br><span class="line">        <span class="comment">// hotPage可以理解为当前正在使用的page</span></span><br><span class="line">        AutoreleasePoolPage *page = <span class="built_in">hotPage</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fixme I think this `while` can be `if`, but I can't prove it</span></span><br><span class="line">        <span class="keyword">while</span> (page-&gt;<span class="built_in">empty</span>()) {</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            <span class="built_in">setHotPage</span>(page);</span><br><span class="line">        }</span><br><span class="line">   </span><br><span class="line">        page-&gt;<span class="built_in">unprotect</span>();</span><br><span class="line">        <span class="comment">// obj = page-&gt;next; page-&gt;next--;</span></span><br><span class="line">     id obj = *--page-&gt;next;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span>*)page-&gt;next, SCRIBBLE, <span class="built_in"><span class="keyword">sizeof</span></span>(*page-&gt;next));</span><br><span class="line">        page-&gt;<span class="built_in">protect</span>();</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// POOL_BOUNDARY为nil，是哨兵对象</span></span><br><span class="line">        <span class="keyword">if</span> (obj != POOL_BOUNDARY) {</span><br><span class="line">         <span class="comment">// 释放obj对象</span></span><br><span class="line">            <span class="built_in">objc_release</span>(obj);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 重新设置hotPage</span></span><br><span class="line">    <span class="built_in">setHotPage</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">// we expect any children to be completely empty</span></span><br><span class="line"> <span class="keyword">for</span> (AutoreleasePoolPage *page = child; page; page = page-&gt;child) {</span><br><span class="line">     <span class="built_in">assert</span>(page-&gt;<span class="built_in">empty</span>());</span><br><span class="line">    }</span><br><span class="line">   <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></blockquote><h4 id="kill-方法-—-删除双向链表中的每一个page"><a href="#kill-方法-—-删除双向链表中的每一个page" class="headerlink" title="kill()方法 —- 删除双向链表中的每一个page"></a>kill()方法 —- 删除双向链表中的每一个page</h4><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Not recursive: we don't want to blow out the stack </span></span><br><span class="line">    <span class="comment">// if a thread accumulates a stupendous amount of garbage</span></span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 找到链表最末尾的page</span></span><br><span class="line">    <span class="keyword">while</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage *deathptr;</span><br><span class="line">    <span class="comment">// 循环删除每一个page</span></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        deathptr = page;</span><br><span class="line">        page = page-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (page) {</span><br><span class="line">            page-&gt;<span class="built_in">unprotect</span>();</span><br><span class="line">            page-&gt;child = nil;</span><br><span class="line">            page-&gt;<span class="built_in">protect</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">delete</span> deathptr;</span><br><span class="line">    } <span class="keyword">while</span> (deathptr != <span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><p><strong>通过源码方法实现解读的：</strong></p><ol><li><p><code>AutoreleasePoolPage</code>每个对象会开辟4096字节内存（虚拟内存一页的大小）</p></li><li><p>除了上面<code>AutoreleasePoolPageData</code>的实例变量（结构体的大小）所占空间，剩下的空间全部用来储存<code>autorelease</code>对象的地址</p><blockquote><p>（注意，<code>AutoreleasePoolPage</code>的第一页会包含哨兵对象，哨兵对象占位8字节，现每个加入的对象为8字节，那么第一页最多可以存储504个对象，从第二页开始最多可以存储505个对象。）</p></blockquote></li><li><p><code>AutoreleasepoolPage </code>通过压栈的方式来存储每个<code>autorelease</code>的对象(<font color="red">从低地址到高地址</font>)。</p></li><li><p><code>next</code>指针作为游标指向栈顶最新<code>add</code>进来的<code>autorelease</code>对象的下一个位置,</p><blockquote><p>当 <code>next</code>指针指向<code>begin</code>时，表示 <code>AutoreleasePoolPage </code>为空；</p><p>当 <code>next</code>指针指向<code>end</code>时，表示 <code>AutoreleasePoolPage</code> 已满;</p></blockquote></li><li><p>当向<code>AutoreleasePool</code>中新增<code>autorelease</code>对象时，底层<code>autoreleaseFast</code>函数内会：</p><ul><li>当前<code>AutoreleasePoolPage</code>没满：直接将该对象插入此page中</li><li>当前<code>AutoreleasePoolPage</code>满了：新建一个<code>AutoreleasePoolPage</code>对象(作为child，自然原来的page变成了parent)，并设置<code>child</code>为<code>hotPage</code>，<code>parent</code>为<code>coldPage</code>，将该对象插入hotPage中；</li><li>当前<code>AutoreleasePoolPage</code>为空：新建一个<code>AutoreleasePoolPage</code>对象，设置为hotPage，再将该对象插入hotPage中；</li></ul></li><li><p>当销毁Autoreleasepool时,Autoreleasepool::pop函数内会：</p><ul><li>根据哨兵对象获取目标page地址</li><li>通过root page拿到hotpage(),从hotPage的next指针开始向boundary之后的所有对象发送release消息</li><li>所有对象发完release消息之后，调用kill方法删除空page （memory: delete empty children）；</li></ul></li></ol><h1 id="6-AutoreleasePool的嵌套"><a href="#6-AutoreleasePool的嵌套" class="headerlink" title="6. AutoreleasePool的嵌套"></a>6. AutoreleasePool的嵌套</h1><p>查看两个嵌套的AutoreleasePool在内存中的结构：</p><p>源码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool {</span><br><span class="line">       for (int i = 0; i&lt;5; i++) {</span><br><span class="line">           YLAnimal *tmpAni = [YLAnimal animal2];</span><br><span class="line">       }</span><br><span class="line">       @autoreleasepool {</span><br><span class="line">           for (int i = 0; i&lt;10; i++) {</span><br><span class="line">               YLDog *tmpAni = [YLDog doggy2];</span><br><span class="line">           }</span><br><span class="line">           _objc_autoreleasePoolPrint();</span><br><span class="line">       }</span><br><span class="line">       </span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>打印结果：</p><img src="../assets/images/内存管理-autoreleasepool_嵌套.png" alt="pool嵌套" style="zoom:80%;"><p>其内部对象释放过程：</p><p>与单一autoreleasepool没有区别，主要是明白一点：<strong>任何释放池在释放时都是从内侧pool开始释放，不存在一个直接从外层pool开始的情况；</strong></p><p>以上面结构为例，一定是先释放boundary 2 所在的pool；然后才能轮到 boundary 1 的pool；当释放到boundary 1 pool时，bound 2pool已经被销毁了，所以最终释放的都是一个单层的pool；</p><p>总结：</p><ul><li>一个pool 有且只有一个boundary，但是可以有N个page</li><li>一个page内可能有1个、0个、多个boundary</li></ul><h1 id="TODO：7-哪些对象会自动加入autoreleasepool？"><a href="#TODO：7-哪些对象会自动加入autoreleasepool？" class="headerlink" title="TODO：7. 哪些对象会自动加入autoreleasepool？"></a>TODO：7. 哪些对象会自动加入autoreleasepool？</h1><img src="../assets/images/内存管理-autorelease_汇编code.png" alt="pool嵌套" style="zoom:100%;"><ul><li><strong>+(instancetype)自定义的的工厂方法创建的对象一定会加入到autoreleasepool中吗？</strong></li><li>alloc 的对象一定不会加到autoreleasepool中</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存布局-OC类与对象</title>
      <link href="/blog/2018/09/07/nei-cun-bu-ju-oc-lei-yu-dui-xiang/"/>
      <url>/blog/2018/09/07/nei-cun-bu-ju-oc-lei-yu-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Clang使用"><a href="#1-Clang使用" class="headerlink" title="1. Clang使用"></a>1. Clang使用</h1><h2 id="1-1-借助clang命令将上层OC代码还原成-C-代码"><a href="#1-1-借助clang命令将上层OC代码还原成-C-代码" class="headerlink" title="1.1 借助clang命令将上层OC代码还原成 C++代码"></a>1.1 借助clang命令将上层OC代码还原成 <code>C++</code>代码</h2><blockquote><p>打开<strong>终端</strong>， cd 到指定的OC文件所在目录下，键入指令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc 对应OC文件.m -o OC文件同名.cpp</span><br></pre></td></tr></tbody></table></figure><p>也可以指定架构，键入指令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc 对应OC文件.m -o OC文件同名.cpp</span><br></pre></td></tr></tbody></table></figure><p>为了更好的观察<code>底层</code>的一些<code>结构</code> 及 <code>实现</code>的逻辑,学会使用clang命令；</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp </span><br><span class="line">//UIKit报错</span><br><span class="line">clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk main.m</span><br><span class="line">// xcrun命令基于clang基础上进行了封装更好用</span><br><span class="line">//3、模拟器编译</span><br><span class="line">xcrun -sdk iphonesimulator clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp </span><br><span class="line">//4、真机编译</span><br><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main- arm64.cpp </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="1-2-借助clang命令将上层OC代码还原成-汇编代码"><a href="#1-2-借助clang命令将上层OC代码还原成-汇编代码" class="headerlink" title="1.2  借助clang命令将上层OC代码还原成 汇编代码"></a>1.2  借助clang命令将上层OC代码还原成 汇编代码</h2><blockquote><p>打开<strong>终端</strong>， cd 到指定的OC文件所在目录下，键入指令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></tbody></table></figure><p>也可以指定架构，键入指令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator clang -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></tbody></table></figure></blockquote><h1 id="2-OC中的三种对象："><a href="#2-OC中的三种对象：" class="headerlink" title="2. OC中的三种对象："></a>2. OC中的三种对象：</h1><ul><li>instance对象</li><li>class对象</li><li>meta-class对象</li></ul><h2 id="2-1-instance对象"><a href="#2-1-instance对象" class="headerlink" title="2.1 instance对象"></a>2.1 instance对象</h2><p>instance对象在内存中存储的信息  包括：</p><ul><li><p>isa指针</p></li><li><p>其他成员变量</p><table><thead><tr><th>实例对象：（堆区，初始化时指向它的指针在栈区）</th></tr></thead><tbody><tr><td>isa（前8个字节）<br>成员变量值<br>…</td></tr></tbody></table></li></ul><h2 id="2-2-class对象"><a href="#2-2-class对象" class="headerlink" title="2.2 class对象"></a>2.2 class对象</h2><p>class对象在内存中存储的信息 主要包括：</p><ul><li><p>isa指针</p></li><li><p>superclass指针</p></li><li><p>类的属性信息（Property）</p></li><li><p>类的成员变量信息（Ivar）</p></li><li><p>对象方法信息（Instance Method）</p></li><li><p>类的协议信息（Protocol）</p><table><thead><tr><th>类对象：（全局区）</th></tr></thead><tbody><tr><td>isa （前8个字节）<br>superClass （8个字节）<br>成员变量信息<br>属性信息<br>对象方法信息<br>协议信息<br>….</td></tr></tbody></table></li></ul><h2 id="2-3-meta-class对象"><a href="#2-3-meta-class对象" class="headerlink" title="2.3 meta-class对象"></a>2.3 meta-class对象</h2><p>meta-class对象在内存中存储的信息主要包括：</p><ul><li><p>isa指针</p></li><li><p>superclass指针</p></li><li><p>类方法信息（Class Method）</p><table><thead><tr><th>元类对象：（全局区）</th></tr></thead><tbody><tr><td>isa （前8个字节）<br>superClass （8个字节）<br>类方法信息<br>…</td></tr></tbody></table></li></ul><h2 id="2-4-经典图isa-amp-super走向"><a href="#2-4-经典图isa-amp-super走向" class="headerlink" title="2.4 经典图isa&amp; super走向"></a>2.4 经典图isa&amp; super走向</h2><img src="../assets/images/内存布局_OC类与对象_isa_super.jpg" alt="isa_super" style="zoom:60%;"><h2 id="2-5-总结："><a href="#2-5-总结：" class="headerlink" title="2.5 总结："></a>2.5 总结：</h2><p><strong>isa指向:</strong></p><blockquote><p>instance对象 —&gt; class对象 —-&gt; meta-class对象 —-&gt; NSObject(Meta) —-&gt; NSObject(Meta) 自己</p><p>🌰：person —&gt; YLPerson —-&gt; YLPerson(Meta) —-&gt; NSObject(Meta) —-&gt; NSObject(Meta) 自己</p></blockquote><p><strong>super指向:</strong></p><blockquote><p>自定义class对象 —-&gt; NSObject —-&gt; nil</p><p>🌰：son —-&gt; YLPerson —-&gt; NSObject —-&gt; nil </p></blockquote><p><strong>调试指令</strong></p><blockquote><p>x是读取内存的命令，x/4gx中第一个x是读取内存命令，后面的g是每次读取8字节，x的意思是16进制显示结果，4表示连续打印4段</p></blockquote><ol><li><p>打印对象内存结构，获取<strong>ISA</strong>指针信息：<strong>x/4gx vc</strong></p><p>0x7fd03d605730: 0x000000010bb22280 0x0000000000000000</p><p>0x7fd03d605740: 0x0000000000000000 0x0000000000000000</p></li><li><p>用 <strong>ISA</strong> 与 <strong>ISA_MASK</strong> 做“与”操作，获取类信息： po 0x000000010bb22280 &amp; 0x007ffffffffffff8ULL（<strong>TARGET_OS_SIMULATOR</strong> 下的 <strong>ISA_MASK</strong>）</p></li></ol><img src="../assets/images/内存布局_OC类与对象_isa.jpg" alt="内存地址" style="zoom:80%;"><h1 id="3-类的结构分析"><a href="#3-类的结构分析" class="headerlink" title="3. 类的结构分析"></a>3. 类的结构分析</h1><h2 id="3-1-类的本质"><a href="#3-1-类的本质" class="headerlink" title="3.1 类的本质"></a>3.1 类的本质</h2><p>类的本质是一个<code>objc_class</code>类型的结构体，<code>objc_class</code>继承于<code>objc_object</code>;</p><h3 id="3-1-1-类在底层的定义"><a href="#3-1-1-类在底层的定义" class="headerlink" title="3.1.1 类在底层的定义:"></a>3.1.1 类在底层的定义:</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object {</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>{ </span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>内存占用情况：</p><ul><li> ISA: Class本身就是一个指针，占用8字节</li><li> superclass: superclass是Class类型，所以占用8字节</li><li> cache： <font color="red"><code>cache_t</code>占用16字节？？？</font></li><li> bits:</li></ul></blockquote><h2 id="3-2-isa分析"><a href="#3-2-isa分析" class="headerlink" title="3.2 isa分析"></a>3.2 isa分析</h2><h3 id="3-2-1-isa-t结构解析"><a href="#3-2-1-isa-t结构解析" class="headerlink" title="3.2.1 isa_t结构解析"></a>3.2.1 isa_t结构解析</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持arm64之后，之前只有一个class成员变量：</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> {</span></span><br><span class="line">    <span class="built_in">isa_t</span>() { }</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="keyword">uintptr_t</span> value) : <span class="built_in">bits</span>(value) { }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    Class cls;</span><br><span class="line">  </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>isa_t</strong> 其实是一个联合体<strong>union :</strong> 一个<strong>8</strong>字节指针**(64<strong>位</strong>) = cls = bits =** 使用位域的<strong>struct</strong> </p><p>联合体**(union)**是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。(如下，要么cls有值，要么bits有值；两者不可能同时有值)</p><blockquote><p><strong>简介：</strong></p><p>ARM64位架构之前，<code>isa</code>是一个指针，指向<code>class/meta-class</code>对象的地址 ；</p><p>ARM64位架构开始(也就是13年5s面世)，<code>isa</code>是一个联合体/共用体（<code>union</code>），这是苹果对<code>isa</code>的优化，结合位域的概念以及位运算的方式来存储更多类相关信息，简单来说就是<code>isa</code>指针通过一个叫<code>ISA_MASK</code>的值进行二进制&amp;运算，得到真实的<code>class/meta-class</code>对象的真实地址。</p></blockquote><h3 id="3-2-2-isa源码-amp-各位代表含义"><a href="#3-2-2-isa源码-amp-各位代表含义" class="headerlink" title="3.2.2 isa源码&amp;各位代表含义"></a>3.2.2 isa源码&amp;各位代表含义</h3><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x86_64 架构</span></span><br><span class="line"><span class="keyword">struct</span> {</span><br><span class="line">    uintptr_t nonpointer        : <span class="number">1</span>;  <span class="comment">// 0:代表普通指针，1:代表被优化过，使用位域存储更多信息</span></span><br><span class="line">    uintptr_t has_assoc         : <span class="number">1</span>;  <span class="comment">// 对象是否含有或曾经含有关联引用</span></span><br><span class="line">    uintptr_t has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">// 表示是否有C++析构函数或OC的dealloc</span></span><br><span class="line">    uintptr_t shiftcls          : <span class="number">44</span>; <span class="comment">// 存放着 Class、Meta-Class 对象的内存地址信息</span></span><br><span class="line">    uintptr_t magic             : <span class="number">6</span>;  <span class="comment">// 用于在调试时分辨对象是否未完成初始化</span></span><br><span class="line">    uintptr_t weakly_referenced : <span class="number">1</span>;  <span class="comment">// 是否被弱引用指向</span></span><br><span class="line">    uintptr_t deallocating      : <span class="number">1</span>;  <span class="comment">// 对象是否正在释放</span></span><br><span class="line">    uintptr_t has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">// 是否需要使用 sidetable 来存储引用计数</span></span><br><span class="line">    uintptr_t extra_rc          : <span class="number">8</span>;  <span class="comment">// 引用计数能够用 8 个二进制位存储时，直接存储在这里</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// arm64 架构</span></span><br><span class="line"><span class="keyword">struct</span> {</span><br><span class="line">    uintptr_t nonpointer        : <span class="number">1</span>;  <span class="comment">// 0:代表普通指针，1:代表被优化过，使用位域存储更多信息</span></span><br><span class="line">    uintptr_t has_assoc         : <span class="number">1</span>;  <span class="comment">// 对象是否含有或曾经含有关联引用</span></span><br><span class="line">    uintptr_t has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">// 表示是否有C++析构函数或OC的dealloc</span></span><br><span class="line">    uintptr_t shiftcls          : <span class="number">33</span>; <span class="comment">// 存放着 Class、Meta-Class 对象的内存地址信息</span></span><br><span class="line">    uintptr_t magic             : <span class="number">6</span>;  <span class="comment">// 用于在调试时分辨对象是否未完成初始化</span></span><br><span class="line">    uintptr_t weakly_referenced : <span class="number">1</span>;  <span class="comment">// 是否被弱引用指向</span></span><br><span class="line">    uintptr_t deallocating      : <span class="number">1</span>;  <span class="comment">// 对象是否正在释放</span></span><br><span class="line">    uintptr_t has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">// 是否需要使用 sidetable 来存储引用计数</span></span><br><span class="line">    uintptr_t extra_rc          : <span class="number">19</span>;  <span class="comment">// 引用计数能够用 19 个二进制位存储时，直接存储在这里</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>注： 在 64 位环境下，优化的 isa 指针并不是就一定会存储引用计数，毕竟用 19bit （iOS 系统）保存引用计数不一定够。需要注意的是这 19 位保存的是引用计数的值减一。has_sidetable_rc 的值如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中。（源码实现：如果是优化过的isa，extra_rc+1就是引用计数，如果有SideTable，就从SideTable拿到引用计数，从SideTable拿到的引用计数加上extra_rc+1就是总的引用计数。）</p><h4 id="3-2-2-1-几个比较重要的字段"><a href="#3-2-2-1-几个比较重要的字段" class="headerlink" title="3.2.2.1 几个比较重要的字段"></a>3.2.2.1 几个比较重要的字段</h4><ul><li><p>nonpointer （标记是否开启指针优化）</p><blockquote><ul><li><p>0，代表普通的指针，存储着<code>Class</code>、<code>Meta-Class</code>对象的内存地址 —- （**<font color="red">未开启isa优化</font>** ）</p><p>如果nonpointer为0，代表raw isa，也就是没有结构体的部分，访问对象的 isa 会直接返回一个指向 cls 的指针，也就是在 iPhone 迁移到 64 位系统之前时 isa 的类型。</p></li><li><p>1，代表优化过，使用位域存储更多的信息 —–（<font color="red"><strong>开启isa优化</strong></font> ）</p></li></ul></blockquote></li><li><p>has_sidetable_rc (标记是否使用SideTable存储引用计数)</p><blockquote><ul><li>0，那么引用计数会存储在<code>extra_rc</code>中,`extra_rc）就是总的引用计数。（<font color="red">开启指针优化 &amp;&amp; extra_rc字段移未溢出的情况下</font>）</li><li>1 ，引用计数会存储在一个叫 SideTable 的类的RefcountMap属性中; 从SideTable拿到的引用计数加上<code>extra_rc</code>+<code>1</code>就是总的引用计数。（<font color="red"> 1.未开启指针优化 ; 2.开启指针优化 &amp;&amp; &nbsp;extra_rc字段移溢出的情况下</font>）</li></ul></blockquote></li><li><p>extra_rc (开启指针优化的对象，存放其引用计数)</p><blockquote><p><font color="red">注意：objc4-818版本之后extra_rc 值就是有效引用计数值不加1；alloc 初始化时<code>extra_rc</code>==1；,之前是在rootRetainCount里+1</font></p></blockquote></li><li><p>shiftcls (存放着 Class、Meta-Class 对象的内存地址信息)</p><blockquote><p><code>isa</code>&amp;<code>ISA_MASK</code> : 结果显示<code>高17位</code>是<code>0</code>，<code>低3位</code>是<code>0</code>，中间的<code>44位</code>是<code>1</code>，用来显示<code>isa</code>中的<code>shiftcls</code>。<code>ISA_MASK</code> 就像一个面具把露出来的显示，其它的全部抹掉。</p></blockquote></li></ul><h3 id="3-2-3-isa实例化方式"><a href="#3-2-3-isa实例化方式" class="headerlink" title="3.2.3 isa实例化方式"></a>3.2.3 isa实例化方式</h3><blockquote><p>由isa源码得知，isa_t提供了两个成员，<code>cls</code>  和 <code> bits</code>，由联合体的定义所知，这两个成员是<strong>互斥</strong>的，也就意味着，当初始化isa指针时，有两种初始化方式</p><ul><li>通过<code>cls</code>初始化，<code>bits</code>无默认值</li><li>通过<code>bits</code>初始化，<code>cls</code> 有默认值</li></ul></blockquote><h3 id="3-2-4-验证isa-t位域"><a href="#3-2-4-验证isa-t位域" class="headerlink" title="3.2.4 验证isa_t位域"></a>3.2.4 验证isa_t位域</h3><p>方法：使用objc源码构建可编译工程，然后在main中的<code>[YLPerson alloc]</code> (注：YLPerson未开启<code>+load</code>方法)断点 –&gt; <code>initInstanceIsa</code> –&gt; <code>initIsa</code> –&gt; 走到<code>else</code>中的 <code>isa</code>初始化;</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// isa初始化底层代码</span><br><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, UNUSED_WITHOUT_INDEXED_ISA_AND_DTOR_BIT bool hasCxxDtor)</span><br><span class="line">{ </span><br><span class="line">    ASSERT(!isTaggedPointer()); </span><br><span class="line">    </span><br><span class="line">    isa_t newisa(0);</span><br><span class="line"></span><br><span class="line">    if (!nonpointer) { // 通过cls初始化，不设置bits默认值</span><br><span class="line">        newisa.setClass(cls, this);</span><br><span class="line">    } else {</span><br><span class="line">        ASSERT(!DisableNonpointerIsa);</span><br><span class="line">        ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">      </span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">        ASSERT(cls-&gt;classArrayIndex() &gt; 0);</span><br><span class="line">        newisa.bits = ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">        // isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        // isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();</span><br><span class="line">#else</span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE; </span><br><span class="line">        // isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        // isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">#   if ISA_HAS_CXX_DTOR_BIT</span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">#   endif</span><br><span class="line">        newisa.setClass(cls, this); // 通过bits初始化，设置cls默认值</span><br><span class="line">#endif</span><br><span class="line">        newisa.extra_rc = 1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // This write must be performed in a single store in some cases</span><br><span class="line">    // (for example when realizing a class because other threads</span><br><span class="line">    // may simultaneously try to use the class).</span><br><span class="line">    // fixme use atomics here to guarantee single-store and to</span><br><span class="line">    // guarantee memory order w.r.t. the class index table</span><br><span class="line">    // ...but not too atomic because we don't want to hurt instantiation</span><br><span class="line">    isa = newisa;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>通过bits初始化前后对比：</p><img src="/Users/tangh/yuki/iOS练习Demos/YLNote/YLNote/latest/个人笔记/文章/images/内存管理_isa_验证位域.jpg" alt="isa验证bits位域" style="zoom:80%;"><p>其中<code>magic</code>是<code>59</code>是由于将<code>isa</code>指针地址转换为<code>二进制</code>，从<code>47</code>（因为前面有4个位域，共占用47位，地址是从0开始）位开始读取<code>6</code>位，再转换为<code>十进制</code>，如下图所示</p><img src="../assets/images/内存管理_isa_验证位域_0.jpg" alt="isa验证bits位域" style="zoom:80%;"><h3 id="3-2-5-isa-与-类-的关联"><a href="#3-2-5-isa-与-类-的关联" class="headerlink" title="3.2.5 isa 与 类 的关联"></a>3.2.5 isa 与 类 的关联</h3><p><code>cls</code> 与 <code>isa</code> 关联<code>原理</code>就是<code>isa</code>指针中的<code>shiftcls</code>位域中存储了<code>类信息</code>，其中<code>initInstanceIsa</code>的过程是将 <code>calloc</code> 指针 和当前的 <code>类cls</code> 关联起来，有以下几种验证方式：</p><ul><li>【方式一】通过以上<code>initIsa</code>方法中的<code>newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</code>验证</li><li>【方式二】通过<code>isa指针地址</code>与<code>ISA_MSAK</code> 的值 <code>&amp;</code> 来验证</li><li>【方式三】通过runtime的方法<code>object_getClass</code>验证</li><li>【方式四】通过<code>位运算</code>验证</li></ul><p>参考：链接：<a href="https://juejin.cn/post/6949580932479189029">https://juejin.cn/post/6949580932479189029</a></p><h2 id="3-3-chceh-t分析"><a href="#3-3-chceh-t分析" class="headerlink" title="3.3 chceh_t分析"></a>3.3 chceh_t分析</h2><h3 id="3-3-1-chceh-t底层源码"><a href="#3-3-1-chceh-t底层源码" class="headerlink" title="3.3.1 chceh_t底层源码"></a>3.3.1 chceh_t底层源码</h3><p>objc790,：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span>  * _<span class="title">buckets</span>;</span>  <span class="comment">//  散列表, 是一个数组, 数组里面的每一个元素就是一个bucket_t, bucket_t里面存放着 SEL 和一个IMP。IMP是一个函数指针，指向了一个方法的具体实现。</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;         <span class="comment">//  _mask是指掩码数据，用于在哈希算法或者哈希冲突算法中计算哈希下标，其中mask 等于capacity - 1</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;  <span class="comment">// 表示哈希表中&nbsp;sel-imp&nbsp;的占用大小&nbsp;(即可以理解为分配的内存中已经存储了sel-imp的的个数)</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>objc818，：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    explicit_atomic&lt;<span class="keyword">uintptr_t</span>&gt; _bucketsAndMaybeMask;            <span class="comment">// 8</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">            explicit_atomic&lt;<span class="keyword">mask_t</span>&gt;    _maybeMask;              <span class="comment">// 4 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line">            <span class="keyword">uint16_t</span>                   _flags;                  <span class="comment">// 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">uint16_t</span>                   _occupied;               <span class="comment">// 2</span></span><br><span class="line">        };</span><br><span class="line">        explicit_atomic&lt;<span class="keyword">preopt_cache_t</span> *&gt; _originalPreoptCache; <span class="comment">// 8</span></span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="bucket-t结构"><a href="#bucket-t结构" class="headerlink" title="bucket_t结构"></a><strong>bucket_t结构</strong></h4><p>bucket_t 中sel，imp的顺序对应在不同平台先后顺序不一样；</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.3.2 cache_t 的 insert 操作主要分为以下几步：</span><br><span class="line"></span><br><span class="line">&gt; - 【第一步】计算出当前的缓存占用量</span><br><span class="line">&gt;</span><br><span class="line">&gt; ​    根据occupied的值计算出当前的缓存占用量，关于缓存占用量的计算，有以下几点说明：</span><br><span class="line">&gt;</span><br><span class="line">&gt; - - alloc申请空间时，此时的对象已经创建，如果再调用init方法，occupied也会+1</span><br><span class="line">&gt;   - 当有属性赋值时，会隐式调用set方法，occupied也会增加，即有几个属性赋值，occupied就会在原有的基础上加几个</span><br><span class="line">&gt;   - 当有方法调用时，occupied也会增加，即有几次调用，occupied就会在原有的基础上加几个</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 【第二步】根据 缓存占用量 判断执行的操作</span><br><span class="line">&gt;</span><br><span class="line">&gt; - - 如果是第一次创建，则默认开辟4个</span><br><span class="line">&gt;   - 如果缓存占用量小于等于3/4（newOccupied + CACHE_END_MARKER &lt;=  capacity * 3 / 4），则不作任何处理</span><br><span class="line">&gt;   - 如果缓存占用量超过3/4，则需要进行两倍扩容以及调用 **realloc**方法 重新开辟空间</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 【第三步】针对需要存储的bucket进行内部imp和sel赋值</span><br><span class="line">&gt;</span><br><span class="line">&gt; ​    这部分主要是根据cache_hash方法，即哈希算法 ，计算sel-imp存储的哈希下标，分为以下三种情况：</span><br><span class="line">&gt;</span><br><span class="line">&gt; - - 如果哈希下标的位置未存储sel，即该下标位置获取sel等于0，此时将sel-imp存储进去，并将occupied占用大小加1</span><br><span class="line">&gt;   - 如果当前哈希下标存储的sel 等于 即将插入的sel，则直接返回</span><br><span class="line">&gt;   - 如果当前哈希下标存储的sel 不等于 即将插入的sel，则重新经过cache_next方法 即哈希冲突算法，重新进行哈希计算，得到新的下标，再去对比进行存储</span><br><span class="line"></span><br><span class="line">### 3.3.3 面试题</span><br><span class="line"></span><br><span class="line">&gt; _mask是什么？</span><br><span class="line">&gt;</span><br><span class="line">&gt; 答： _mask是指掩码数据，用于在哈希算法或者哈希冲突算法中计算哈希下标，其中mask 等于capacity - 1。</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br><span class="line">&gt; occupied 是什么？</span><br><span class="line">&gt;</span><br><span class="line">&gt; 答：_occupied表示哈希表中 sel-imp 的占用大小 (即可以理解为分配的内存中已经存储了sel-imp的的个数)，</span><br><span class="line">&gt;</span><br><span class="line">&gt; &gt; * init会导致occupied变化</span><br><span class="line">&gt; &gt; * 属性赋值，也会隐式调用，导致occupied变化</span><br><span class="line">&gt; &gt; * 方法调用，导致occupied变化</span><br><span class="line">&gt;</span><br><span class="line">&gt; 为什么随着方法调用的增多，其打印的occupied 和 mask会变化？</span><br><span class="line">&gt;</span><br><span class="line">&gt; 答： 因为在cache初始化时，分配的空间是4个，随着方法调用的增多，当存储的sel-imp个数，即newOccupied + CACHE_END_MARKER（等于1）的和 超过 总容量的3/4时，例如总容量为4，当occupied 等于2时，就需要对cache的内存进行两倍扩容。</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line"></span><br><span class="line">https://juejin.cn/post/6976938077822386190#heading-3</span><br><span class="line"></span><br><span class="line">https://juejin.cn/post/6978501444911497247#heading-1</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">## 3.4 TODO： class_data_bits_t分析（理解了runtime方法加载过程再来补充）</span><br><span class="line"></span><br><span class="line">### 3.4.3  ivar解析</span><br><span class="line"></span><br><span class="line">#### 3.4.3.1 **ivarLayout** 与 **weakIvarLayout** 规则解析</span><br><span class="line"></span><br><span class="line">ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型。</span><br><span class="line"></span><br><span class="line">具体记录规则：</span><br><span class="line"></span><br><span class="line">- 首先由于 ivarLayout 与 weakIvarLayout 都是 uint8_t 类型，在 16 进制下是两位，所以编码的值每两位一对儿</span><br><span class="line">- ivarLayout：数据可拆解为 每两位为一组，一组中第一位表示连续的 非Strong修饰的数量，第二位为 Strong 修饰的数量，最后两位 **00** 为结束符，就像 cstring 的 **\0** 一样</span><br><span class="line">- weakIvarLayout：数据可拆解为 每两位为一组，一组中第一位表示连续的 非Weak修饰的数量，第二位为 Weak 修饰的数量，最后两位 **00** 为结束符，就像 cstring 的 **\0** 一样</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">🌰代码 1：</span><br><span class="line"></span><br><span class="line">​```objc</span><br><span class="line">@interface Foo : NSObject {</span><br><span class="line">  __strong id ivar0;</span><br><span class="line">  __weak id ivar1;</span><br><span class="line">  __weak id ivar2;</span><br><span class="line">}</span><br><span class="line">@end</span><br></pre></td></tr></tbody></table></figure><p>则储存 strong ivar 的 ivarLayout 的值为 <strong>0x012000</strong></p><p>储存 weak ivar 的 weakIvarLayout 的值为 <strong>0x1200</strong></p><p>🌰代码 2：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Bar</span> : <span class="title">NSObject</span> </span>{</span><br><span class="line">  __<span class="keyword">weak</span> <span class="keyword">id</span> ivar0;</span><br><span class="line">  __<span class="keyword">strong</span> <span class="keyword">id</span> ivar1;</span><br><span class="line">  __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> ivar2;</span><br><span class="line">  __<span class="keyword">weak</span> <span class="keyword">id</span> ivar3;</span><br><span class="line">  __<span class="keyword">strong</span> <span class="keyword">id</span> ivar4;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure><p>则储存 strong ivar 的 ivarLayout 的值为 <strong>0x112100</strong></p><p>储存 weak ivar 的 weakIvarLayout 的值为 <strong>0x01211000</strong></p><h1 id="4-对象的结构分析"><a href="#4-对象的结构分析" class="headerlink" title="4. 对象的结构分析"></a>4. 对象的结构分析</h1><h2 id="4-1-对象的本质"><a href="#4-1-对象的本质" class="headerlink" title="4.1 对象的本质"></a>4.1 对象的本质</h2><img src="../assets/images/内存布局_OC类与对象_对象的本质_0.png" alt="YLPet编译前" style="zoom:50%;"><img src="../assets/images/内存布局_OC类与对象_对象的本质_1.png" alt="YLPet编译后" style="zoom:50%;"><p>结合源码分析：</p><p>YLPet的底层实现是一个struct。其内容为YLPet_IMPL ：</p><ul><li>NSObject_IVARS： // 继承自 <code>NSObject</code> 的<code>isa</code>;NSObject 底层只有一个”isa“变量，所以继承来的只有这一个变量</li><li>gender：成员变量ivar</li><li>_name：属性name，自动添加  “__”生成对应的成员变量</li><li>_age：属性age，自动添加  “__”生成对应的成员变量</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> {</span></span><br><span class="line">  <span class="keyword">isa_t</span> isa;</span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> {</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Accessing the class requires custom ptrauth operations, so</span></span><br><span class="line">    <span class="comment">// force clients to go through setClass/getClass by making this</span></span><br><span class="line">    <span class="comment">// private.</span></span><br><span class="line">    Class cls;</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对象的本质是一个<code>objc_object</code>类型的结构体，其内部只有一个isa指针。</p><h2 id="4-2-Tagged-Pointer对象（特例）"><a href="#4-2-Tagged-Pointer对象（特例）" class="headerlink" title="4.2 Tagged Pointer对象（特例）"></a>4.2 Tagged Pointer对象（特例）</h2><h3 id="4-2-1-为什么要使用taggedPointer"><a href="#4-2-1-为什么要使用taggedPointer" class="headerlink" title="4.2.1 为什么要使用taggedPointer?"></a>4.2.1 为什么要使用taggedPointer?</h3><blockquote><p>假设要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，在64位CPU下是占8个字节的。1个字节有8位，如果我们存储一个很小的值，会出现很多位都是0的情况，这样就造成了内存浪费，苹果为了解决这个问题，引入了taggedPointer的概念。</p><p>以NSNumber为例，对象占用内存空间情况：</p><p>arm64之前：指针（8个字节）+ NSNumber对象（16个字节 内存对齐）</p><p>arm64之后：TaggedPointer指针（只占8字节）</p></blockquote><ul><li><strong>Tagged Pointer</strong>是苹果为了解决32位CPU到64位CPU的转变带来的内存占用和效率问题，针对<strong>NSNumber、NSDate</strong>以及部分<strong>NSString</strong>的内存优化方案。</li><li><strong>Tagged Pointer指针</strong>的值不再是地址了，而是真正的值。所以，实际上它<strong>不再是一个对象</strong>了，它只是一个披着对象皮的普通变量而已。所以，它的<strong>内存并不存储在堆中（而是在栈上），也</strong>不需要malloc和free**。</li><li><strong>Tagged Pointer指针</strong>中包含了当前对象的地址、类型、具体数值。因此Tagged Pointer指针在内存读取上有着3倍的效率，创建时比普通需要<strong>malloc</strong>跟<strong>free</strong>的类型<strong>快106倍</strong>。</li></ul><h3 id="4-2-2-内存结构"><a href="#4-2-2-内存结构" class="headerlink" title="4.2.2 内存结构"></a>4.2.2 内存结构</h3><img src="../assets/images/内存管理_taggedPointer_64.jpg" alt="TaggedPointerbit分布图" style="zoom:50%;"><img src="../assets/images/内存管理_taggedPointer_64_2.jpg" alt="TaggedPointerbit分布图" style="zoom:50%;"><p>注意：与macOS不同，iOS系统采用 <code>MSB</code>（<code>Most Significant Bit</code>，即最高有效位）为<code>Tagged Pointer</code>标志位。</p><h3 id="4-2-3-各bit含义解释"><a href="#4-2-3-各bit含义解释" class="headerlink" title="4.2.3 各bit含义解释"></a>4.2.3 各bit含义解释</h3><ul><li><p>_OBJC_TAG_MASK: 占1bit，是<code>Tagged Pointer</code>标志位，1意味着该地址是<code>Tagged Pointer</code>，0则不是。</p></li><li><p>Extended_Tag_Index：占8bit，只有当Tag_Index=7的时候才存在，表示这是一个用于扩展的标志位，会额外占用8位来存储扩展的Tag Index。类标识的基本类型和扩展类型我们可以在<code>Runtime</code>源码中的<code>objc_tag_index_t</code>查到：</p><img src="/Users/tangh/Library/Application Support/typora-user-images/image-20210806165118167.png" style="zoom:30%;"></li><li><p>Tag_Index：占3bit，是类标志位，可以在<code>Runtime</code>源码中查看<code>NSNumber</code>、<code>NSDate</code>、<code>NSString</code>等类的标志位。</p></li><li><p>Payload：对NSNumber而言，最多占56bit，最少占48bit（取决于Tag Index是否为extended tag index），存储具体的数值。</p></li><li><p>Type_Index: 占4bit，代表NSNumber具体的数据类型，具体的对应关系：</p><table><thead><tr><th>Type_Index</th><th>对应数据类型</th></tr></thead><tbody><tr><td>0</td><td>char</td></tr><tr><td>1</td><td>usigned char, short</td></tr><tr><td>2</td><td>unsigned short,int</td></tr><tr><td>3</td><td>unsigned int,NSInteger,NSUInteger,long,unsigned long,long long,unsigned long long</td></tr><tr><td>4</td><td>float</td></tr><tr><td>5</td><td>double</td></tr></tbody></table><p>结论：<code>Tagged Pointer</code>可表示的数字范围是-2^55+1 ~ 2^55-1，对于超出这个范围的数字，NSNumber会自动转换为普通的内存分配在堆上的OC对象。</p></li></ul><h3 id="4-2-4-如何判断指针是否为Tagged-Pointer"><a href="#4-2-4-如何判断指针是否为Tagged-Pointer" class="headerlink" title="4.2.4 如何判断指针是否为Tagged Pointer"></a>4.2.4 如何判断指针是否为Tagged Pointer</h3><p>在 <a href="https://link.juejin.cn/?target=https://github.com/Kanthine/SourceCode/blob/51fd88340a1d76047dcb8bb02e47f14482d00706/objc4-750/runtime/objc-internal.h">objc runtime</a>源码中找到了 _objc_isTaggedPointer()的实现：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> _objc_isTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr){</span><br><span class="line">    <span class="comment">//将一个指针地址和 _OBJC_TAG_MASK 常量做 &amp; 运算：判断该指针的最高位或者最低位为 1，那么这个指针就是 Tagged Pointer。</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">uintptr_t</span>)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>_OBJC_TAG_MASK</code> 的定义：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OBJC_MSB_TAGGED_POINTERS <span class="comment">//MSB 高位优先</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63) <span class="comment">//Tagged Pointer 指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">//LSB 低位优先</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_MASK 1UL <span class="comment">//Tagged Pointer 指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>因此<code> ptr &amp; _OBJC_TAG_MASK</code> 按位与运算之后如果判断标志位为1则该指针是Tagged Pointer 。</p><h3 id="4-2-5-TaggedPointer混淆原理："><a href="#4-2-5-TaggedPointer混淆原理：" class="headerlink" title="4.2.5 TaggedPointer混淆原理："></a>4.2.5 TaggedPointer混淆原理：</h3><p>混淆原理：使用一个随机数<code>objc_debug_taggedpointer_obfuscator</code>对真正的内存地址异或操作。根据异或运算的特性，a^b^b=a，因此只需要将混淆后的地址再与<code>objc_debug_taggedpointer_obfuscator</code>异或一次就能够完成反混淆。</p><h3 id="4-2-6-附：Tagged-Pointer-针对-obj-msg-send-的处理"><a href="#4-2-6-附：Tagged-Pointer-针对-obj-msg-send-的处理" class="headerlink" title="4.2.6 附：Tagged Pointer 针对 obj_msg_send 的处理"></a>4.2.6 <strong>附</strong>：Tagged Pointer 针对 <strong>obj_msg_send</strong> 的处理</h3><p>​    •    对于内置Tagged Pointer类型的对象来说，其中的高四位保存的是一个索引值，通过这个索引值可以在objc_debug_taggedpointer_classes数组中查找到对象所属的Class对象；</p><p>​    •    对于自定义扩展Tagged Pointer类型的对象来说，其中的高52位到59位这8位bit保存的是一个索引值，通过这个索引值可以在objc_debug_taggedpointer_ext_classes数组中查找到对象所属的Class对象。</p><h2 id="4-3-非TaggedPointer对象"><a href="#4-3-非TaggedPointer对象" class="headerlink" title="4.3 非TaggedPointer对象"></a>4.3 非TaggedPointer对象</h2><p>对象是否不启用Non-pointer目前有这么几个判断条件，这些都可以在runtime源码objc-runtime-new.m中找到逻辑。</p><blockquote><p>1：包含swift代码；<br>2：sdk版本低于10.11；<br>3：runtime读取image时发现这个image包含__objc_rawisa段；<br>4：开发者自己添加了OBJC_DISABLE_NONPOINTER_ISA=YES到环境变量中；<br>5：某些不能使用Non-pointer的类，GCD等；<br>6：父类关闭。</p></blockquote><p>我们自己新建一个Person类，通过OBJC_DISABLE_NONPOINTER_ISA=YES/NO来看看isa结构体的具体内容:</p><h3 id="4-3-1-non-poniter：0-对象"><a href="#4-3-1-non-poniter：0-对象" class="headerlink" title="4.3.1 non-poniter：0 对象"></a>4.3.1 non-poniter：0 对象</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">isa_t</span> isa = {</span><br><span class="line">    Class class = Person;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits = <span class="number">4294976320</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> nonpointer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls = <span class="number">536872040</span>; </span><br><span class="line">        <span class="keyword">uintptr_t</span> magic = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">其实可以简化为</span><br><span class="line"><span class="keyword">isa_t</span> isa = {</span><br><span class="line">    Class class = Person;</span><br><span class="line">}</span><br><span class="line">因为源码中显示不使用Non-pointer则只对isa的<span class="class"><span class="keyword">class</span>赋值了，其他的都是默认值，而且除了<span class="keyword">class</span>其他成员也不会在源码中被使用到。</span></span><br></pre></td></tr></tbody></table></figure><h3 id="4-3-2-non-poniter：1-对象"><a href="#4-3-2-non-poniter：1-对象" class="headerlink" title="4.3.2 non-poniter：1 对象"></a>4.3.2 non-poniter：1 对象</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">isa_t</span> isa = {</span><br><span class="line">    Class class = Person;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits = <span class="number">8303516107940673</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> nonpointer = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls = <span class="number">536872040</span>; </span><br><span class="line">        <span class="keyword">uintptr_t</span> magic = <span class="number">59</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">extra_rc就是存的引用计数，nonpointer = <span class="number">1</span>表示启用Non-pointer。</span><br></pre></td></tr></tbody></table></figure><h1 id="5-alloc源码探索"><a href="#5-alloc源码探索" class="headerlink" title="5. alloc源码探索"></a>5. alloc源码探索</h1><h2 id="5-1-alloc调用堆栈："><a href="#5-1-alloc调用堆栈：" class="headerlink" title="5.1 alloc调用堆栈："></a>5.1 alloc调用堆栈：</h2><p><code>+ alloc</code> —-&gt; <code>_objc_rootAlloc</code> —&gt; <code>callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);</code> —-&gt; <code>_objc_rootAllocWithZone</code> —&gt; <code>_class_createInstanceFromZone</code>；</p><p>核心代码<code>_class_createInstanceFromZone</code>方法内部实现：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, <span class="keyword">size_t</span> extraBytes, <span class="keyword">void</span> *zone,</span><br><span class="line">                              <span class="keyword">int</span> construct_flags = OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>,</span><br><span class="line">                              <span class="keyword">size_t</span> *outAllocatedSize = nil)<span class="comment">// alloc 源码 第五步</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">ASSERT</span>(cls-&gt;<span class="built_in">isRealized</span>()); <span class="comment">//检查是否已经实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read class's info bits all at once for performance</span></span><br><span class="line">    <span class="comment">//一次性读取类的位信息以提高性能</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;<span class="built_in">hasCxxCtor</span>();</span><br><span class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;<span class="built_in">hasCxxDtor</span>();</span><br><span class="line">    <span class="keyword">bool</span> fast = cls-&gt;<span class="built_in">canAllocNonpointer</span>();</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算需要开辟的内存大小，传入的extraBytes 为 0</span></span><br><span class="line">    size = cls-&gt;<span class="built_in">instanceSize</span>(extraBytes);</span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    <span class="keyword">if</span> (zone) {</span><br><span class="line">        obj = (id)<span class="built_in">malloc_zone_calloc</span>((<span class="keyword">malloc_zone_t</span> *)zone, <span class="number">1</span>, size);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">//申请内存</span></span><br><span class="line">        obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!obj)) {</span><br><span class="line">        <span class="keyword">if</span> (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) {</span><br><span class="line">            <span class="keyword">return</span> _objc_callBadAllocHandler(cls);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!zone &amp;&amp; fast) {</span><br><span class="line">        <span class="comment">//将 cls类 与 obj指针（即isa） 关联</span></span><br><span class="line">        obj-&gt;<span class="built_in">initInstanceIsa</span>(cls, hasCxxDtor);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be</span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">        obj-&gt;<span class="built_in">initIsa</span>(cls);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!hasCxxCtor)) {</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_cxxConstructFromClass</span>(obj, cls, construct_flags);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="5-2-核心三步："><a href="#5-2-核心三步：" class="headerlink" title="5.2 核心三步："></a>5.2 核心三步：</h2><ul><li><p>计算instancesize （<strong>这里有一个16字节对齐</strong>）</p><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size = cls-&gt;<span class="built_in">instanceSize</span>(extraBytes);</span><br></pre></td></tr></tbody></table></figure><p>为什么需要16字节对齐?</p><p>​        需要字节对齐的原因，有以下几点：</p><ul><li>通常内存是由一个个字节组成的，cpu在存取数据时，并不是以字节为单位存储，而是以<code>块</code>为单位存取，块的大小为内存存取力度。频繁存取字节未对齐的数据，会极大降低cpu的性能，所以可以通过<code>减少存取次数</code>来<code>降低cpu的开销</code></li><li>16字节对齐，是由于在一个对象中，第一个属性<code>isa</code>占<code>8</code>字节，当然一个对象肯定还有其他属性，当无属性时，会预留8字节，即16字节对齐，如果不预留，相当于这个对象的isa和其他对象的isa紧挨着，容易造成访问混乱</li><li>16字节对齐后，可以<code>加快CPU读取速度</code>，同时使<code>访问更安全</code>，不会产生访问混乱的情况</li></ul></blockquote></li><li><p>开辟空间大小，返回对象地址</p><blockquote><p>通过<code>instanceSize</code>计算的内存大小，向内存中申请 大小 为 size的内存，并赋值给obj，因此 obj是指向内存地址的指针</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li><p>类与isa关联</p><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;<span class="built_in">initInstanceIsa</span>(cls, hasCxxDtor);</span><br></pre></td></tr></tbody></table></figure><p>_class_createInstanceFromZone 内部:  </p><p><code>obj-&gt;initInstanceIsa(cls, hasCxxDtor);</code> —&gt;   <code>initIsa(cls, true, hasCxxDtor); </code>  –&gt;   <code> newisa.setClass(cls, this);</code></p></blockquote></li></ul><h1 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6.面试题"></a>6.面试题</h1><h4 id="什么是类？什么是对象？"><a href="#什么是类？什么是对象？" class="headerlink" title="什么是类？什么是对象？"></a>什么是类？什么是对象？</h4><p>答：在面向对象中，我们使用<font color="red"><strong>类</strong></font>来描述<font color="red"><strong>具有特定属性和行为的一类事物</strong></font>，它是一个模板；而对象是模板的一个具象实体。</p><h4 id="NSObject对象的本质是什么？"><a href="#NSObject对象的本质是什么？" class="headerlink" title="NSObject对象的本质是什么？"></a>NSObject对象的本质是什么？</h4><p>答：本质是一个objc_object的结构体，其成员变量只有一个isa指针；</p><h4 id="objc-object-与-对象的关系"><a href="#objc-object-与-对象的关系" class="headerlink" title="objc_object 与 对象的关系"></a>objc_object 与 对象的关系</h4><p>答：<strong>OC中所有继承自<code>NSObject</code>类生成的对象，都是<code>struct objc_object</code>类型</strong>。</p><p><strong>OC中所有继承自<code>NSObject</code>的类生成的对象，都具有Class类型的<code>isa</code>成员</strong></p><blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Object.mm line 34</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>从这里我们可以知道，**<code>id</code>是一个指向<code>struct objc_object</code>的指针类型；**</p><p>OC中所有继承自<code>NSObject</code>类生成的对象，都是<code>struct objc_object</code>类型<strong>。</strong></p><p>OC中所有继承自<code>NSObject</code>的类生成的对象，都具有Class类型的<code>isa</code>成员**</p><p>那么<code>Class</code>又是什么东西？其实在查看<code>id</code>类型的原始声明时，就看到了下面这句：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Object.mm line 33</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>原来<code>Class</code>就是一个指向<code>struct objc_class</code>的指针类型。所以我们平时定义的<code>类</code>也就是以<code>struct objc_class</code>作为支撑。再瞅瞅<code>objc_class</code>结构体：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// objc-runtime-new.h line 1145</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object {</span><br><span class="line"> <span class="comment">// Class ISA;</span></span><br><span class="line"> Class superclass;</span><br><span class="line"> <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line"> <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">     <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line"> }</span><br><span class="line"> ...</span><br><span class="line">} </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这里是一个<code>C++</code>定义的结构体，可以继承以及定义方法。根据这个实现，我们可以知道：</p><ol><li><code>Class</code>也是对象，因为它继承自<code>objc_object</code>。</li><li><code>Class</code>也有<code>isa</code>成员，继承自<code>objc_object</code>，这点很重要，在方法的调用过程时会用到。`</li><li>除了<code>isa</code>，该结构体还包含了父类指针<code>superclass</code>，和该类相关联的缓存<code>cache</code>以及该类的具体信息<code>bits</code>;</li></ol></blockquote><h4 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h4><p>答：类的本质是一个<code>objc_class</code>类型的结构体，<code>objc_class</code>继承于<code>objc_object</code>。</p><h4 id="id、instancetype、NSObject-的区别"><a href="#id、instancetype、NSObject-的区别" class="headerlink" title="id、instancetype、NSObject * 的区别"></a>id、instancetype、NSObject * 的区别</h4><p>答：</p><table><thead><tr><th>类型</th><th>使用范围</th><th>静态or动态</th></tr></thead><tbody><tr><td>id</td><td>* 定义变量； <br>* 定义方法返回值；<br>*  定义方法参数。</td><td>动态类型对象；<br>编译时编译器不会检查id对象的类型，<br>只有在运行时动态检查后会报错。<br></td></tr><tr><td>instancetype</td><td>* 只可作为函数返回值</td><td>动态类型 <br>（扩大关联返回类型的方法范围，<br>不再只是cocoa定义的特定关键字开头）<br>作用：可以使那些<font color="red"><strong>非关联返回类型</strong></font>的方法返回所在类的类型</td></tr><tr><td>NSObject *</td><td>* 定义变量； <br>* 定义方法返回值；<br>*  定义方法参数。</td><td>静态类型<br>编译时会进行类型检查。</td></tr><tr><td>id<nsobject> *</nsobject></td><td></td><td>只要遵循<nsobject>协议的任何一种类型；</nsobject></td></tr></tbody></table><blockquote><p>Objective-C中的动态类型和静态类型**</p><ul><li><p>动态类型</p><p>动态类型指的是对象指针类型的动态性，具体是指使用<code>id</code>修饰后将对象的类型确定推迟到运行时，由赋给它的对象类型决定对象指针的类型。也就是说<code>id</code>修饰的对象为动态类型对象，其他在编译器指明类型的为静态类型对象，通常如果不需要涉及到多态的话还是要尽量使用静态类型（原因：错误可以在编译器提前查出，可读性好）。</p></li><li><p>静态类型</p><p>一个指针变量指向特定类的对象时，使用的是静态类型，在编译的时候就知道这个指针变量所属的类。使用静态类型时，编译器在编译期间，会做许多的类型检查：因为编译器需要知道哪个对象该如何使用。</p></li></ul><p><strong>关联返回类型和非关联返回类型</strong></p><ul><li><p>关联返回类型涉及的方法</p><ul><li><p>类方法：以alloc、new 开头的</p></li><li><p>实例方法：以<code>autorelease</code>，<code>init</code>，<code>retain</code>或<code>self</code>开头</p><p>当这些方法返回值为<code>id</code>类型时，编译器不会返回一个类型不明的对象，会返回一个方法所在类类型的对象，这些方法就被称为是关联返回类型的方法。换句话说，这些方法的返回结果以方法所在的类为类型。</p><p>🌰：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface YLAnimal : NSObject</span><br><span class="line">              </span><br><span class="line">+ (id)newTestObject;  // 返回一个自动关联为YLAnimal类型的对象</span><br><span class="line">+ (id)allocTestObject;// 返回一个自动关联为YLAnimal类型的对象</span><br><span class="line">+ (id)testObject;// 返回一个类型不明的对象</span><br><span class="line">@end</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>非关联返回类型</p><ul><li>非以上关键字开头的方法,返回值不关联所属类的类型，会返回一个类型不明的对象;</li></ul></li></ul></blockquote><h1 id="TODO-关于NSProxy与NSObject"><a href="#TODO-关于NSProxy与NSObject" class="headerlink" title="TODO : 关于NSProxy与NSObject"></a>TODO : 关于NSProxy与NSObject</h1><img src="../assets/images/内存布局_OC类与对象_NSObject.jpg" alt="NSobject" style="zoom:80%;"><img src="../assets/images/内存布局_OC类与对象_NSProxy.jpg" style="zoom:80%;"><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
